# 1. 事件机制

Redis 中的事件驱动库，它只会去关注**网络 I/O事件**，以及**定时器事件**。

所以，Redis 的事件库处理下面两类事件：

1. **文件事件（file event）**：用于处理 **Redis 服务器和客户端之间的网络I/O事件**
2. **时间事件（time event）**：用于处理 Redis 服务器中的一些**需要在给定时间点执行的操作**（比如 `serverCron函数`）

Redis 中的事件驱动库的代码主要在 `src/ae.c` 中实现的：

![img](2021-12-20-Redis事件机制.assets/db-redis-event-1.png)

- aeEventLoop：整个事件驱动库的核心，它管理着**文件事件表**和**时间事件表**，==不断的循环处理**就绪的文件事件**和**到期的时间事件**==。



# 2. 文件事件

Redis 基于 **Reactor模式** 开发了自己的网络I/O事件处理器，也就是文件事件处理器，文件事件处理器使用 **I/O 多路复用技术**（参考 Java IO多路复用）：==同时监听多个套接字（socket），并为套接字关联不同的事件处理函数。当套接字的可读或者可写事件触发，就会调用相应的事件处理函数。==



## 2.1 为什么单线程的 Redis 能那么快？

Redis 的性能瓶颈不在 CPU 而是在 I/O，所以为了节省开发量，在 6.0 版本前的 Redis 是单线程模型；其次，**Redis 的单线程主要是指 Redis 的网络I/O 和键值对的读写都是由一个线程来完成的**，这也是 Redis 对外提供键值对存储服务的主要流程。

但是，Redis 的其它功能，比如说是 持久化、异步删除、集群数据同步等都是由额外的线程完成的。

Redis 采用**多路复用机制**使其在**网络 I/O 操作事件**中能**并发**处理大量的客户端请求，**实现高吞吐率。**



## 2.2 Redis 事件响应框架 ae_event 及文件事件处理器

> Redis 并没有使用 **libevent** 或者 **libev** 这样成熟的开源方案，而是自己实现了一个非常简洁的事件驱动库 **ae_event**。----- pdai

Redis 使用的I/O事件多路复用技术主要有：`select、epoll、evport、kqueue`等。

每个 **IO 多路复用函数库在 Redis 源码中都对应着一个单独**的 **.c** 文件。==Redis 会根据不同的操作系统，按照不同的优先级来选取不同的多路复用技术==，而一般的**事件响应框架**都会采取类似的架构，比如 **netty** 和 **libevent**。

![img](2021-12-20-Redis事件机制.assets/db-redis-event-2.png)

如下图所示，文件事件处理器有四个组成部分，它们分别是`套接字、I/O多路复用程序、文件事件分派器、事件处理器`：

![img](2021-12-20-Redis事件机制.assets/db-redis-event-3.png)

文件事件是对套接字操作的抽象，每当一个**套接字**准备好执行的时候 `accpet、read、write、close`等操作时，就会产生一个文件事件，==因为 Redis 通常会将多个套接字连接在一起，所以多个文件事件有可能会并发的出现==。

上图中，**I/O 多路复用程序负责监听多个套接字**，并向**文件事件派发器**传递那**些产生了事件的套接字**。

尽管多个文件事件可能会并发地出现，但**I/O多路复用程序**总是会将所有产生的套接字都放到同一个队列，`这个队列就是 aeEventLoop 中 fired 就绪事件列表`，然后文件**事件处理器**会以`有序、同步、单个套接字`的方式**处理该队列中的套接字**，也就是**处理就绪的文件事件**。

所以一次 Redis 客户端与服务器进行连接并且发送命令的过程就是下面这张图：

![img](2021-12-20-Redis事件机制.assets/db-redis-event-4.png)

**我们来说明一下这张图：**

1. 客户端向 Redis 服务的发起**建立 socket 套接字连接的请求**，那么监听套接字将产生 `ae_readable` 事件，触发**连接应答处理器**处理客户端的连接请求。
2. 服务端进行应答，然后创建客户端套接字，客户端状态，并**将客户端套接字的 `ae_readable` 事件与命令请求处理器相关联**。
3. 然后客户端向服务端**发送命令**，那么客户端套接字将产生 `ae_readable` 事件，服务端接收到命令之后找到上一步中该客户端关联的命令请求处理器去处理。
4. **执行命令获得相应的命令回复**，为了将命令回复传递给客户端，服务器将客户端套接字的 `ae_readable` 事件与命令回复处理器关联。当**客户端试图读取命令回复时**，**客户端套接字**产生 `ae_readable` 事件，触发命令回复处理器将命令回复全部写入到套接字中。



## 2.3 Redis I/O 多路复用模型

在 Redis 只允许当线程的情况下，**该机制允许内核中，同时存在多个监听套接字和已连接套接字**。

内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就**实现了==一个 Redis 线程==处理多个 I/O 流的效果。**

![img](2021-12-20-Redis事件机制.assets/db-redis-event-0.jpg)

- FD：上面说的多个套接字，Redis 网络框架调用 epoll 机制，让内核监听多个套接字。

此时 ==Redis 线程不会阻塞在**某一个特定的监听套接字或已连接套接字上**，换句话来说就是**不会阻塞在某一个客户端的请求的处理上**==。正是因为如此，所以 Redis 可以同时和多个客户端建立连接并且处理请求，**提升并发率性**。

因为 **Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能**，因为请求分发，都交给 **Linux** 内核去做了。

比如，**连接请求**和**读数据请求**，这是两个不同的请求，他们分别对应 **Accept 事件和 Read 事件**，需要不同的事件处理器，Redis 分别对这两个事件注册 **accept** 和 **get** 回调函数。Linux 内核监听到有连接请求或者读数据请求，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。

`Liunx内核接到请求 ----> 触发请求对应的事件 ----> 调用相应的回调函数 ----> Redis 接收，处理`

拿生活中的例子来说，就像医院，医院就相当于内核，Redis线程就相当于一个医生，病人在实际见到医生之前，会经历分诊，找到对应的科，然后再到医生，这样即使一个医生，那么也不用让这个医生来进行病人的分诊而是专注于做一件事，就是看病，这样效率就提高了。



# 3. 时间事件

Redis 中的事件事件分为以下两类：

1. **定期事件**：程序在指定的时间段之后执行一次
2. **周期性事件**：程序在每个周期到了都会执行一次

```c
typedef struct aeTimeEvent {
    /* 全局唯一ID */
    long long id; /* time event identifier. */
    /* 秒精确的UNIX时间戳，记录时间事件到达的时间*/
    long when_sec; /* seconds */
    /* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/
    long when_ms; /* milliseconds */
    /* 时间处理器 */
    aeTimeProc *timeProc;
    /* 事件结束回调函数，析构一些资源*/
    aeEventFinalizerProc *finalizerProc;
    /* 私有数据 */
    void *clientData;
    /* 前驱节点 */
    struct aeTimeEvent *prev;
    /* 后继节点 */
    struct aeTimeEvent *next;
} aeTimeEvent;
```

一个时间事件是定时事件还是周期事件都取决于时间处理器的返回值：

- **ae_nomore 返回值**：代表是一个定时事件，做完就删。
- **非 ae_nomore 返回值**：代表周期事件，服务器根据时间处理器的返回值，对时间事件的 **when** 属性进行更新，让这个事件在一段时间后再次到达。

![img](2021-12-20-Redis事件机制.assets/db-redis-event-5.png)

服务器所有的时间事件都放在一个无序链表中，每当事件执行器允许时，他就会**遍历整个链表，然后找到所有已到达的时间事件**，并调用相应的事件处理器，正常模式下，**Redis** 服务器只使用 `serverCron`函数 这一个时间事件，而在 **benchmark** 模式下，服务器也只使用两个时间事件，所以不影响事件的执行性能。 



# 4. aeEventLoop 具体实现

建议往下读的话，得先去学一下 Java I/O 多路复用详解



## 4.1 创建时间管理