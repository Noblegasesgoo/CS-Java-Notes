# 1. 为什么需要主从复制？

因为我们只要是存数据的数据库，如果说要避免单点故障，保证高可用，我们得需要副本方式提供集群服务。**Redis** 提供了主从库模式，以保证数据副本一致，主从库之间采用的是读写分离的方式。



# 2. Redis 主从复制的概述

主从复制，是指将一台 Redis 服务器的数据，复制到其它结点的  Redis 服务器。

数据复制是单向的，只能由主节点到从节点。

主从复制的作用：

1. **数据冗余：**
   - 主从复制主要实现了数据的热备份，是持久化之外一种数据备份方式。
2. **故障恢复：**
   - 主节点出现问题的时候，可以先让从节点顶上，实现快速的故障恢复。
3. **负载均衡：**
   - 可以在主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务，分担服务器压力
4. **高可用基石：**
   - 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，也就是 **Redis** 高可用的基础。

主从库之间采用的是**读写分离**的方式：

1. **读操作：**主库从库都可以接收，提升读的效率。
2. **写操作：**首先到主库执行，然后复制到从库。

![img](2021-12-26-Redis的主从复制.assets/db-redis-copy-1.png)



# 3. 主从复制原理

一般有两种：

1. **全量（同步）复制：**比如一次同步时。
2. **增量（同步）复制：**只会把主从库网络断连时期主库收到的命令同步给从库。



## 3.1 全量复制

我们启动多个 **Redis** 实例的时候，他们相互之间就可以通过 **`replicaof`** （**Redis 5.0** 之前使用的是 **`salveof`**） 命令形成主库和从库的关系，之后会按照三个阶段来完成数据的第一次同步。



### 3.1.1 确认主从关系

我们来举个例子，比如一个 实例1 其ip地址为：1.1.1.1，实例2 其ip地址为：1.1.1.2，我们在实例2上执行以下这个命令后，实例2 就变成了 实例1 的从库，并从 实例1 上复制数据：

```shell
replicaof 1.1.1.1 6379
```



### 3.1.2 全量复制的三个阶段

下面是三个阶段的整体流程图：

![img](2021-12-26-Redis的主从复制.assets/db-redis-copy-2.jpg)

我们来康康到底是怎么进行的：

**首先第一阶段：建立连接，协商同步**，主要是为全量复制做准备，这一步中，主库和从库建立起连接，并且告诉主库我们从库即将进行同步，主库确认回复后，主从库就可以开始同步了。

具体下来就是：从库给主库发送 **`psync ？-1`** 命令，表示请求进行数据同步，主库要根据这个命令所带参数来启动复制。**`psync`** 命令包含了主库的 **`runID`** 和复制阶段 **`offset`** 两个参数：

- **runID：**每个 **Redis** 实例启动时都会自动生成的一个**随机ID**，它**描述唯一的实例**。**第一次**主从复制时，因为不知道主库的 **`runID`** ，所以将 **`runID`** 设置为 ？。
- **`offset`**：偏移量，此时设置为 -1 ，表示第一次主从复制。

主库收到 **`psync`** 命令之后，会使用 **`fullresync`** 响应命令，并且带上自己的 **`runID`** 和 复制进度 **`offset`**，返回给从库。从库收到响应之后，会保存这俩个参数。

注：**`fullresync`** 命令响应第一次主从复制时，是采用**全量复制**，也就是说，第一次主从复制，主库会把所有数据同步到从库。

**其次是第二阶段：主库同步数据给从库**，在从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照生产的 **RDB** 文件。

具体来说，主库持久化，执行 **`bgsave`** 命令，生成 **RDB** 文件并且将其发送给从库。从库接收到 **RDB** 文件后，会先清空当前数据库，然后加载 **RDB** 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。

为了避免之前数据的影响，从库需要先把当前数据库清空，再主从同步的过程中，主库不会被阻塞，仍然可以正常接受请求，不然的话 **Redis** 的服务就中断了，并且这些请求中的写操作并没有记录到刚刚的 **RDB** 文件里。

所以为了保证主从数据一致性，主库会在内存中用专门的 **`replicaiton buffer`**，记录 **RDB** 文件生成后收到的所有写操作。

**最后是第三阶段：主库把第二阶段中收到的新的写命令，再次发送给从库**，当主库 RDB 文件发送后，会接着将 **`replication buffer`** 中新到的写操作发给从库，然后从库去执行这些写操作。

至此，完成主从同步。



## 3.2 增量复制

在 Redis 2.8 版本引入了增量复制。



### 3.2.1 这玩意到底为啥出现啊？

如果没有增量复制从库在命令传播时出现了断网，那么主从复制就得重新进行全量复制，如果经常发生这种情况的话，开销非常大。所以从 **Redis 2.8** 开始，网络断了之后，主从复制就会采用增量复制继续同步。



### 3.2.2 增量复制的流程

继续是一张图：

![img](2021-12-26-Redis的主从复制.assets/db-redis-copy-3.jpg)

- **repl_backlog_buffer：**
  - 这玩意就是避免主从之间网络中断造成的数据不一致，但是又不想恢复连接后得重新全量复制而设计的环形缓冲区。如果从库断开很长时间，**`repl_backlog_buffer`** 环形缓冲区被主库的写命令覆盖了，那么从库连上主库之后只能乖乖的进行一次全量复制，所以，我们给 **`repl_backlog_buffer`** 这个缓冲区的空间，尽可能的大一点，可以降低主从断开之后全量复制的概率。 
- **replication buffer：**
  - 如果在 **`repl_backlog_buffer`** 中找到主从差异的数据之后，如何发给从库呢？
  - **Redis** 在和客户端通信也好，和从库通信也好，**Redis** 都需要分配一个内存缓冲区进行数据交互，客户端是一个 **client**，从库也是一个 **client**。
  - **client** 在连接上 **Redis** 服务器之后，**Redis** 都会分配一个 **`client buffer`**，所有的数据交互都通过这个缓冲区来进行。
  - **Redis** 先把数据写到该缓冲区中，然后再把缓冲区中的数据发送到 **`client socket`** 中再通过网络发送出去，至此完成数据交互。
  - 所以主从在增量同步的时候，从库作为一个客户端，也会分配有一个缓冲区，只不过这个缓冲区此时专门用来传播用户的写命令到从库，保证主从数据一致性，我们通常把这个缓冲区称为 **`replication buffer`**。



- **如果在网络断开的期间，`repl_backlog_size` 环形缓冲区写满了，从库是会丢掉被覆盖掉的数据还是直接进行全量复制呢？**

这个问题我们可以考虑两个关键点：

1. 一个从库如果和主库断连时间过长，此时如果主库的 **`repl_backlog_buffer`** 的 **`slave_repl_offset`** 位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。
2. 每个从库会记录自己的 **`slave_repl_offset`**，每个从库的复制进度也不一定相同。在和主库重新连接恢复时，从库会通过 **`psync`** 命令把自己记录的 **`slave_repl_offset`** 发给主库，主库会根据从库各自的复制进度，来决定这个从库可以进行增量复制，还是全量复制。也就是读复制进度条，进度条到哪，就从哪开始。



# 4. 一些思考



## 4.1 主服务器不进行持久化时的安全性

在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。

为什么不持久化主服务器自动启动会是一件危险的事情呢？我们可以推演一下。

假设我设置A为主服务器，关闭了持久化，B、C结点作为从服务器，这时候突然出现崩溃，但是 Redis 具有自动重启功能，重启了进程（此时时关闭了持久化），但是重启之后只有一个空的数据集。B、C从结点此时再次建立上连接，进行全量复制，但是复制时要先删除旧的数据，这就导致了全空。

所以如果数据比较重要的话，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都**应该静止实例自动重启**。

## 4.2 为什么主从全量复制要使用 RDB 而不是 AOF 呢？

因为 RDB 是压缩过的二进制文件，AOF 则是记录了每一写次操作，根据他俩的特性来看，RDB 更适合，毕竟主从复制，我们不能占用主服务器太大的网络带宽，主服务器负载就会小一点，并且 RDB 文件更小，并且还是二进制文件，所以从服务器读取起来会更快。而 AOF 每次都得重新执行一遍命令，整个过长对比下来就会很漫长，即使恢复数据，速度也会差很多。

而且我们假设一下用 AOF 来做全量复制，意味着我们必须打开 AOF 功能，打开 AOF 有文件刷盘策略，选择不当的话或多或少都会影响 Redis 的性能，但是 RDB 只是在有需要定时备份或者手动的时候才会生成一次快照，而且在很多数据丢失不敏感的情况下其实是不需要开启 AOF 的，比如菜单表等。

## 4.3 为什么还有无磁盘复制模式？

**无磁盘复制模式：**主服务器创建一个新的进程直接把 RDB 不复制到磁盘而是直接丢到从服务器的 socket，不经过主进程和硬盘。**适用于 disk 比较慢，并且网络较块的时候**。 

虽然 Redis 默认是磁盘复制，但是如果使用的磁盘速度较低的话，会给主服务器复制带来较大的压力。所以 Redis 从 2.8.18 开始尝试支持无磁盘的复制。使用这种设置的时候，子进程将直接将 RDB 通过网络发送给从服务器，这样的话，就省去了磁盘作为中介的时间和效率。

- **`repl-diskless-sync`** 配置参数来启动无磁盘复制；
- **`repl-diskless-sync-delay`** 参数来配置传输开始的延迟时间；

主服务器等待一个 repl-diskless-sync-delay 的时间，如果没有从服务器响应的话，就直接传，后来的得排队等待，否则就一起传。好比现在有默认和 A 和 B 建立连接，时间之内，是可以有 C 来建立的，这时就可以 A 向 B 和 C 同时发送，不然 C 就只能等着 A 给 B 发完才能到自己了。

## 4.4 为什么有从库的从库套娃设计？

我们也知道，因为进行全量复制的时候我们可以看成两步：生成 RDB 文件并传输。这两步是耗时的。

如果一个主库的从库很多的话，那么是不是此时的主从复制，主库的压力就很大，因为主库一直在忙着忙着 **`fork`** 子进程生成 **RDB** 文件，进行数据全量复制。**`fork`** 的时候，会阻塞主线程处理正常请求，从而导致主库响应应用请求变慢。此外，传输 **RDB** 文件也会占用主库的网络带宽，同样会给主库资源使用带来压力。

所以我们想了一个法子，就是主-从-从模式。

**主从从**模式将**主库生成 RDB 和传输 RDB 的压力以级联的方式分散到从库上**。

大概就是这么个样子：

![img](2021-12-26-Redis的主从复制.assets/db-redis-copy-4.jpg)

**一旦主从库完成了全量复制**，它们之间就会**一直维护一个网络连接**，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。

## 4.5 读写分离及其中出现的问题

在主从复制的基础上实现的读写分离，可以实现 Redis 的读负载均衡：主服务器负责写操作，多个从服务器负责读操作，分担压力，在读负载较大的场景下，可以极大的提升 Redis 的读并发能力。

使用 Redis 读写分离时也需要注意一些问题：

### 4.5.1 主从数据不一致问题（延迟）

由于主从复制 RDB 文件传输的过程是异步的，数据的不一致不可避免的会发生。那么如果我们的应用对数据不一致的接受程度比较低的话，那么可能可以使用的优化方法如下：

1. 尽量将主从服务器和从服务器放在一个机房，这样的话网络环境会好点，结点之间距离短，传输准确且速度更快。
2. 监控主从节点延迟（也就是 offset 同步率）判断，如果结点延迟过大，就通知应用不来这个结点读取，然后优化延迟过大的结点。
3. 使用集群同时扩展写负载和读负载等。

如果在命令传播阶段以外，从节点的数据不一致问题可能会变得更加严重，比如连接在数据同步阶段就正好断网，那这样的话数据不同步问题会更严重，对于这种情况，配置文件中有一个参数：**`slave-seeve-stale-data`** 与此有关。这个参数它控制着这种情况下结点的表现，如果为 **`no`**，则从节点只能响应 **`info、slaveof`** 等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为no。

### 4.5.2 数据过期的问题

单机情况下的 **Redis** 有两个删除策略：

- **惰性删除**：
  - 服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期才删除。也就是由查询被动触发的删除。
- **定期删除**：
  - 定时任务定时删除过期数据，考虑到删除会释放内存，但是频率高的话会影响CPU性能，所以该删除的频率和执行时间都受到了限制。

在联机版（主从复制）情况下，为了主从数据的一致性，从节点不能主动删除过期数据，只能等待主节点控制，但是主节点的删除策略都不能保证主节点对过期数据及时的清理，所以更无法保证从节点的数据一致，所以从从节点读取数据的时候更容易读取到过期数据。

**Redis 3.2**中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将 **Redis** 升级到 3.2 可以解决数据过期问题。

### 4.5.3 故障切换问题

在没有哨兵的读写分离情境下，应用针对读和写分别连接不同的 **Redis** 节点，当主节点或从节点出现问题发生更改时，需要及时修改应用程序读写 **Redis** 数据的连接，连接的切换可以手动进行，或者自己写监控程序进行切换。

但是有利有弊，前者响应慢且容易出错，后者实现复杂成本高。

### 4.5.4 对以上问题的总结

在使用读写分离前可以考虑其他方法增加 **Redis** 的读负载能力：

1. 尽量的去优化主节点：
   - 减少慢查询、减少持久化等其它情况带来的阻塞等等。
2. 使用 **Redis** 集群去提高读、写负载能力。

如果使用读写分离，可以使用哨兵模式，这样的话主从节点的故障切换就尽可能的自动化，并且减少了对应用程序的入侵。

