# 1. Redis持久化简介

我们主要从两个方面来介绍



## 1.1 为什么需要持久化？

通过之前的学习，我们知道，**Redis 它是一个基于内存存储的数据库**，这也是他为什么处理那么快的原因，但是==一旦服务器宕机，那么内存中的所有数据就会丢失==。

通常，我们解决方案是从后端数据库去恢复这些数据，但是后端数据库也会有性能瓶颈，如果涉及到要恢复的数据量特别大，那么：

1. 会给后端数据库带来极大的压力
2. 数据库的数据处理性能没有基于内存的 Redis 的高，导致程序响应变慢

所以，避免宕机之后从后端数据库恢复 Redis 中的数据是不可避免的，那么我们就需要 Redis 也可以数据持久化。



## 1.2 持久化方式有哪些？为什么重点是 RDB 和 AOP？

从严格意义上来说，**Redis** 所提供的**持久化存储解决方案**一共有四种：

1. ==**RDB**==

2. ==**AOP**==

3. **VM（虚拟内存）**：

   从 2.4版 本起，官方就不建议使用，3.2版本 后就没有VM的任何配置和范例，说明官方也放弃了它

4. **DISKSTORE**

   从 2.8版本 开始被提出，但是到现在为止，官方也没有明确推荐使用，同样 3.2版本 中也找不到对于这种方式的明确支持



1. 

# 2. RDB 持久化存储方式

**RDB （Redis DataBase）**，中文名为 快照/内存快照。

RDB 持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻，那么它一定具有滞后性。



## 2.1 触发方式

1. 手动触发
2. 自动触发



### 2.1.1 手动触发

> 手动触发分别对应 **save** 和 **bgsave** 命令。



1. **save 命令：**

   阻塞当前 **Redis** 服务器，知道 RDB 过程完成为止，对于==内存比较大的实例会造成**长时间的阻塞**==，**线上环境不建议使用此命令**。

   

2. **bgsave 命令：**

   Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由此 fork 操作 fork 出来的子进程进行操作，完成后自动结束。

   在 **bgsave命令** 中，阻塞只出现在 fork 子线程的阶段。

   ![img](2021-12-18-Redis的RDB和AOF机制.assets/redis-x-rdb-1.png)

- 最后一步：通知父进程rdb持久化完成，主进程更新相关统计信息（info persitence 下的 rdb _* 相关选项）。
- 

### 2.1.2 自动触发

> 四种自动触发的情况

1. **redis.conf** 中配置 `save <seconds> <changes>`，表示，==在seconds秒内有changes次修改时，自动触发bgsave生成rdb文件==
2. 主从复制时，==从节点要从主节点进行全量复制时==，也会触发 **bgsave 操作**，主节点生成当时的快照发送到从节点
3. 执行 `debug reload 命令`重新加载 redis 时也会触发 **bgsave**操作
4. 默认情况下执行 `shutdown` 命令时，如果没有开启 **AOF持久化**，那么也会触发 **bgsave操作**



## 2.2 redis.conf 中配置 RDB

**快照周期**：内存快照虽然可以通过技术人员手动执行 `save | bgsave 命令`来进行，但是生产环境下多数情况都会设置其周期性执行条件。

- **Redis中新设置默认周期**

```shell
# 周期性执行条件的设置格式为
save <seconds> <changes>

# 设置参考
save 60 2
save 120 10
save 1000 10000
...

# 以下设置方式为关闭RDB快照功能
save ""
```

- **其它相关配置**

```shell
# 快照文件名称
dbfilename dump.rdb

# 快照文件保存路径
dir /home/work/app/redis/data/

# 如果持久化出错，主进程是否停止写入
stop-writes-on-bgsave-error yes

# 快照是否压缩，官方建议使保持 yes，它会将字符串类型的数据启用LZF压缩算法压缩
rdbcompression yes

# 快照导入时是否检查
rdbchecksum yes
```

`stop-writes-on-bgsave-error`：

在**快照操作正常进行的情况**下，Redis的主进程照样可以接收任意客户端的**写操作**的特性；但是如果**快照操作出现异常**，比如操作系统当前使用用户权限不够、磁盘空间不够等等情况时，Redis就会禁止写操作。

主要目的就是为了使运维人员第一时间就发现 Redis 的运行错误并且快速着手解决。

`rdbchecksum`：

从 **RDB** 快照功能的 **version5** 版本开始，一个 64位的 CRC冗余码校验编码会被放在 RDB 文件的末尾，以便于对整个 RDB 文件的完整性进行校验。

虽然这个功能会损失大概 10% 左右的性能，但是获得了数据的高可靠性。



## 2.3 RDB 深入理解

> 下面是别人实战中遇到过的例子

- **问题一：生产环境中，我们都会为 Redis 开辟比较大的内存空间（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间 Redis 服务一般都会收到数据写操作请求，那么==在此情况下如何保证数据一致性呢？==**

  RDB中的核心思路就是用 **copy-on-write（熟悉的写时复制）**来保证在进行快照操作的时间内，需要压缩写入磁盘上的数据在内存中不会发生变化。

  在一般正常进行的快照操作中，一方面 Redis 主进程会 fork 一个新的快照子进程来专门做这个事情，这样保证了 Redis 服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域，也就和我们平时想的不太一样，它是把==快照读进行中的写操作的结果放在另一个新的内存区域，而不是原来的内存区域。==

  **举个例子就是：**

  主线程对这些数据也都是读操作，那么书现场和 bgsave 子进程相互不影响，但是如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据副本，然后，bgsave 子进程会把这个副本数据写入 **RDB文件** 中，而在这个过程中，主线程仍然可以直接修改原来的数据。



![img](2021-12-18-Redis的RDB和AOF机制.assets/redis-x-aof-42.jpg)



- **问题二：在进行快照操作的这段时间内，如果发生服务崩溃怎么办？**

  解决方法就是，==在**没有将数据全部写入磁盘前**，这次快照操作都不算成功，类似事务==。如果出现了服务崩溃的情况，将上一次完整的 RDB快照文件 作为恢复内存数据的参考。

  换句话来说就是，**==快照操作的过程中，不能影响上一次的备份数据==**。

  Redis 服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。

  所以说，**快照操作中的文件是一个临时文件，并不是对上一次快照操作完成后的RDB文件直接进行修改替换**。



- **问题三：可以每秒做一次快照吗？**

  对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。

  如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。 　

![img](2021-12-18-Redis的RDB和AOF机制.assets/redis-x-rdb-2.jpg)

- 所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像“连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。

  这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是，**如果频繁地执行全量快照，也会带来两方面的开销**：

  - 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
  - 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁**阻塞主线程**了。

  那么，有什么其他好方法吗？此时，我们可以做**增量快照**，就是==指做了**一次全量快照**后，**后续的快照只对修改的数据进行快照记录**，这样可以避免每次全量快照的开销==。这个比较好理解。

  但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的**空间开销问题**。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？我们在后面会给出答案。



## 2.4 RDB 的优缺点

1. **优点：**
   - **RDB** 文件时某个时间节点的快照，默认使用 **LZF** 算法进行压缩，压缩后的文件体积远远小于内存中的大小，适用于备份和全量复制等场景下。
   - **Redis** 加载 **RDB** 文件 恢复数据的效率要远远快于 **AOF** 方式。
2. **缺点：**
   - **RBD** 方式实时性不够，**无法做到秒级持久化**，也就存在信息滞后性。
   - 每次调用 `bgsave` 指令都需要 `fork` 子进程，`fork` 子进程属于是重量级偏高的操作，频繁执行的话成本比较高。
   - **RDB** 文件是以二进制形式存在的，没有可读性，**AOF** 文件在了解其结构的情况下可以手动修改或者补全，具有可读性。
   - 版本兼容 **RDB** 文件问题。



# 3. AOF 持久化存储方式

针对==RDB不适合实时持久化的问题，Redis提供了**AOF**持久化方式来解决==。

Redis 是“写后”日志（AppendOnly File），Redis 先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis 收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

AOF 日志采用写后日志，**先写内存，后写日志**。

![img](2021-12-18-Redis的RDB和AOF机制.assets/redis-x-aof-41.jpg)



## 3.1 为什么采用写后日志？

Redis 要求高性能，采用写后日志带来了两方面的好处：

1. **避免额外的检查开销**

   Redis 在向 AOF 里面记录日志的时候，**并不会先去对这些命令进行语法检查**。所以，==如果先记录日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 再使用日志恢复数据时，就可能会出错==。

2. **不会阻塞当前的写操作**

但是，采用写后日志，也有**潜在的风险**：

1. **如果命令执行完成，写日志之前宕机了，会造成数据的丢失**
2. **主线程写磁盘压力大，会导致写盘比较慢，阻塞后续操作**



## 3.2 Redis 如何实现 AOF

==AOF 日志记录 Redis 的每个写命令==，步骤分别为：`命令追加（append）、文件写入（write）、文件同步（sync）。`

- **命令追加：**
  - 当 AOF 持久化功能打开之后，服务器在**执行完一个写命令之后**，会以**协议格式**将被执行的写命令追加到服务器的 `aof_buf` 缓冲区。
- **文件写入和同步：**
  - 关于何时将 aof_buf 缓冲区的内容写入 AOF 文件中，Redis 提供了三种写回策略：

![img](2021-12-18-Redis的RDB和AOF机制.assets/redis-x-aof-4.jpg)

1. `Always`，**同步写回**，每个命令执行完，立马将日志同步回磁盘。
2. `Everysec`，**每秒写回**，每个写命令执行完，只是先把日志文件写到 AOF 文件的内存缓冲区，每隔一秒将缓冲区中的内容写入磁盘。
3. `No`，**操作系统控制的写回**，每个命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。



- **三种写回策略的优缺点**

上面的三种写回策略体现了一个重要原则：**trade-off**，取舍，指在性能和可靠性保证之间做取舍，没有任何方法可以是完美的，只能具体情况具体分析。

关于**AOF的同步策略是涉及到操作系统的 write 函数和 fsync 函数**的，在《Redis设计与实现》中是这样说明的：

>为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。



## 3.3 redis.conf 中配置 AOF

默认情况下，Redis 是没有开启 AOF 的，可以通过配置 `redis.conf` 文件来开启 AOF 持久化，关于AOF的配置如下：

```shell
# appendonly参数开启AOF持久化
appendonly no

# AOF持久化的文件名，默认是appendonly.aof
appendfilename "appendonly.aof"

# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的
dir ./

# 同步策略
# appendfsync always
appendfsync everysec
# appendfsync no

# aof重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发配置
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 加载aof出错如何处理
aof-load-truncated yes

# 文件重写策略
aof-rewrite-incremental-fsync yes
```

- `appendfsync 参数`：
  - 很重要的参数，可以**指定真正执行”操作命令向AOF文件中同步的策略**。
  - 什么叫==真正执行==呢？Linux操作系统为了**保证操作系统中 I/O 队列的操作效率**，应用程序提交 **I/O** 操作请求一般是被放置在 `linux page cache` 中的，然后再由 Linux操作系统 中的策略**自行决定**写到磁盘上的时机。
  - **Redis** 中有个 **fsync() 函数**，可以将 `page cache` 中待写入的数据真实的写入到物理设备（磁盘）上，缺点是频繁调用这个 `fsync()` 函数干预操作系统的既定策略，可能导致 I/O 卡顿的现象频繁发生。
- `no-appendfsync-on-rewrite 参数`：
  - `always` 和 `everysec` 的设置会使得**真正的 I/O 操作变得频繁**，甚至会**出现长时间卡顿现象**，这个问题出在**操作系统层面**，所以靠工作在操作系统之上的进程是无法解决的，只能去尽可能的避免。
  - 为了缓解这个情况，**Redis** 提供了这个选项，以保证在完成 `fsync()` 函数调用时，不会将这段时间内发生的命令操作放入操作系统的 `page cache`（同一时间段内 **Redis** 还在接收着客户端的各种写操作命令）。
- `auto-aof-rewrite-percentage 参数`：
  - 下文会提到，在生产环境下，我们不可能随时随地的去使用 `bgrewriteaof` 命令去重写 AOF 文件。
  - 所以更多时候，我们得依靠 Redis 中对 AOF文件的自动重写策略。
  - 这个参数表示当前 AOF 文件如果大小如果超过了上次重写后 AOF 文件的百分之多少后，就再次开始重写 AOF 文件。
  - 例如我设置为 100，意味着如果 AOF 文件大小超过上次 AOF 文件重写后的 1 倍，就启动重写操作。
- `auto-aof-rewrite-min-size 参数`：
  - 它和上面 `auto-aof-rewrite-percentage 参数`出现的原因一样。
  - 该参数表示启动 AOF 文件 重写操作的 AOF 文件的最小大小。

`auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size`这俩参数设计思路，可以好似看作 JDK8 中 HashMap 的红黑树转换条件，虽然完成的工作不同，但是思路异曲同工。

==值得注意的的是，如果是我们手动调用 `bgrewriteaof` 命令，那么重写操作将不受这俩参数的限制。==













# 参考文章

https://www.pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html







































