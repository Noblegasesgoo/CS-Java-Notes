# 为什么设计Stream

Redis5.0 中还增加了一个数据结构 **Stream**，从字面上看是流类型，但其实从功能上看，应该是Redis对消息队列（MQ，Message Queue）的完善实现。

他是一个新的数据结构，他是一个可以支持多播持久化的消息队列。

![image-20211209103512023](2021-12-09-Redis的Stream.assets/image-20211209103512023.png)

从上图看，它将所有加入的消息形成了一个消息链表，每个小小都有一个唯一的ID以及其对应内容，而且消息是持久化的，所以代表了 **Redis** 重启之后，内容不会消失。

每个 **Stream** 都有**唯一的名称**，就是 **Redis** 的 **Key**，我们在**首次使用 `xadd` 指令**追加消息的时候会自动创建。

每个 **Stream** 都可以挂多个消费组，每个消费组会有个游标 **last_delivered_id** 在 **Stream**  数组之上往前移动，表示当前消费组已经消费到哪条消息了。

- **消费组**：

每个消费组都有一个 **Stream**  内唯一的名称，消费组不会自动创建，它需要单独的指令 `xgroup create` 进行创建，需要指定 从 **Stream** 的某个消息 ID 开始消费，这个 ID 用来初始化 **last_delivered_id** 变量。

每个消费组不会互相影响，状态独立，换句话说就是 **Stream** 内部消息会被每个消费组都消费到。

- **消费者**：

然后同一个消费组中有多个消费者，每个消费者有一个组内唯一ID，消费者之间是竞争关系，任意一个消费者读取了消息之后，**last_delivered_id** 都会往后移动。

消费者内部有个状态变量 **pending_ids** ，它记录了当前已经被客户端读取的消息但是没有确认（ack）。如果此时客户端没有 确认（ack），那么在这个变量里的消息 ID 会越来越多，一旦某个消息被确认，他才开始减少。

这个 pending_ids 变量官方称之为 PEL（Pending Entries List），一个很核心的数据结构，确保客户端至少消费了一次消息，而不会在网络传输中把没处理过的消息丢失。



# 消息ID

消息 ID 的形式它是 **timestampInMillis-sequence**，比如 123132132-21，他表示当前的消息在毫秒时间戳 123132132 产生，并且是该毫秒内的第 21 条消息。

它可以是由服务器自动生成也可是客户端自己指定，但是必须是单调递增。



# 消息内容

消息内容就是键值对，如 hash 结构的键值对。



# 基本操作

|   操作    |                      说明                      |
| :-------: | :--------------------------------------------: |
|   xadd    |                    追加消息                    |
|   xdel    | 删除消息，这里删除时逻辑删除，不影响消息总长度 |
|  xrange   |     获取消息列表，会自动过滤已经删除的消息     |
|   xlen    |                    消息长度                    |
|    del    |                   删除Stream                   |
| xrevrange |          反向获取消息列表，ID从大到小          |
|   xread   |         以阻塞或非阻塞方式获取消息列表         |

```shell
# * 号表示服务器自动生成 ID，后面顺序跟着一堆 key/value
# 名字叫 laoqian，年龄 30 岁
127.0.0.1:6379> xadd codehole * name laoqian age 30 
1527849609889-0 # 生成的消息 ID
127.0.0.1:6379> xadd codehole * name xiaoyu age 29
1527849629172-0
127.0.0.1:6379> xadd codehole * name xiaoqian age 1
1527849637634-0
127.0.0.1:6379> xlen codehole
(integer) 3
# - 表示最小值 , + 表示最大值
127.0.0.1:6379> xrange codehole - +
127.0.0.1:6379> xrange codehole - +
1) 1) 1527849609889-0
   2) 1) "name"
      2) "laoqian"
      3) "age"
      4) "30"
2) 1) 1527849629172-0
   2) 1) "name"
      2) "xiaoyu"
      3) "age"
      4) "29"
3) 1) 1527849637634-0
   2) 1) "name"
      2) "xiaoqian"
      3) "age"
      4) "1"
# 指定最大消息 ID 的列表
127.0.0.1:6379> xrange codehole - 1527849629172-0
1) 1) 1527849609889-0
   2) 1) "name"
      2) "laoqian"
      3) "age"
      4) "30"
2) 1) 1527849629172-0
   2) 1) "name"
      2) "xiaoyu"
      3) "age"
      4) "29"
127.0.0.1:6379> xdel codehole 1527849609889-0
(integer) 1
# 长度不受影响
127.0.0.1:6379> xlen codehole
(integer) 3
# 被删除的消息没了
127.0.0.1:6379> xrange codehole - +
1) 1) 1527849629172-0
   2) 1) "name"
      2) "xiaoyu"
      3) "age"
      4) "29"
2) 1) 1527849637634-0
   2) 1) "name"
      2) "xiaoqian"
      3) "age"
      4) "1"
# 删除整个 Stream
127.0.0.1:6379> del codehole
(integer) 1
```

> 《Redis深度历险：核心原理和应用实践》--- 钱文品



# 独立消费

 Redis允许在不定义消费组的情况下进行 Stream 消息的独立消费，当 Stream 没有新的消息的时候，甚至可以阻塞等待。

`xread` 指令是一个可供独立消费的指令，可以将 **Stream** 当成普通的消息队 列(list) 来使用。

使用 `xread ` 时，我们可以忽略消费组的存在。

```shell
# 从Stream头部读取两条消息
127.0.0.1:6379> xread count 2 streams codehole 0-0
1) 1) "codehole"
   2) 1) 1) 1527851486781-0
         2) 1) "name"
            2) "laoqian"
            3) "age"
            4) "30"
      2) 1) 1527851493405-0
         2) 1) "name"
            2) "yurui"
            3) "age"
            4) "29"
# 从Stream尾部读取一条消息，毫无疑问，这里不会返回任何消息
127.0.0.1:6379> xread count 1 streams codehole $
(nil)
# 从尾部阻塞等待新消息到来，下面的指令会堵住，直到新消息到来
127.0.0.1:6379> xread block 0 count 1 streams codehole $
# 我们从新打开一个窗口，在这个窗口往Stream里塞消息
127.0.0.1:6379> xadd codehole * name youming age 60
1527852774092-0
# 再切换到前面的窗口，我们可以看到阻塞解除了，返回了新的消息内容
# 而且还显示了一个等待时间，这里我们等待了93s
127.0.0.1:6379> xread block 0 count 1 streams codehole $
1) 1) "codehole"
   2) 1) 1) 1527852774092-0
         2) 1) "name"
            2) "youming"
            3) "age"
            4) "60"
(93.11s)
```

客户端如果想要使用 xread 进行顺序消费，一定要记住当前消费到哪里了，也就是返回的消息ID。下次继续调用 xread 时，将上次返回的最后一个 消息ID 作为参数传递进去，就可以继续消费后续的消息。

`block 0`表示**永远阻塞**，直到消息到来，`block 1000`表示**阻塞1s**，如果1s内没有任何消息到来，就返回 **nil**。



# 消费组消费

## 创建消费组

- 基本命令

|        命令        |                解释                |
| :----------------: | :--------------------------------: |
|   xgroup create    |            创建消费者组            |
|  xreadgroup group  |        读取消费者组中的消息        |
|        xack        |         确认消息（已处理）         |
|    xgroup setid    | 为消费者组设置新的最后递送的消息ID |
| xgroup delconsumer |             删除消费者             |
|   xgroup destory   |             删除消费组             |
|      xpending      |      显示待处理消息的相关信息      |
|       xclaim       |          转移消息的归属权          |
|    xinfo groups    |         打印消费者组的信息         |
|    xinfo stream    |             打印流信息             |

![image-20211209115955562](2021-12-09-Redis的Stream.assets/image-20211209115955562.png)

