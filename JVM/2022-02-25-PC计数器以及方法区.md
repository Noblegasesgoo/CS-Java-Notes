## PC计数器

你在编程的时候，你顺序怎么写，程序执行的顺序就是怎么样，如果发生上下文切换的话，PC计数器主要是记录线程执行情况。

每个线程都有一个程序计数器，而且是==**线程私有**==的，就是一个指针，指向**方法区**中的**方法字节码**（用来**存储指向下一条指令**的地址，也就是将要执行的指令代码），由执行引擎去读取下一条指令，是一个非常小的内存空间，在现在的设备看来，几乎可以忽略不计。

**它是当前线程所指向的字节码的行号指示器**。

这块内存区域很小很小，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。



## 方法区

**方法区（Method Area）**，它其实只是 **jvm** 中提出的一种规范，一种约束，一种接口，所以它必须有落地的实现，好比集合框架，**`List`** 接口有不同的实现类。

- **Java 8 之前**：
  - 永久代
- **Java 8 之后**：
  - 元空间

**它是提供各线程共享的运行时内存区域**：

1. 存储了每一个类的结构信息。
2. 提供运行时常量池。
3. 字段和方法数据。
4. 构造函数和普通方法。

以上这些内容的全部字节码内容。

但是上面我们说的这些只是规范，在不同虚拟机里面的实现是不一样的，**最典型就好比 Oracle 公司的不同 Java 版本的元空间（Metaspace）和永久代（PermGen space）**，方法区是一种规范，不同的公司可能有不同的实现，但是都是基于这个规范实现的。

记住，实例变量存在堆内存中，和方法区没有关系。

就比如为啥我们一开始写代码的时候就可以用 **String** 等类的东西，是因为 **jvm** 安装时，就把 **rt.jar** 包下的内容都装进了**元空间**（Java 8），在这个空间里面几乎**不会去产生频繁的垃圾回收**。

垃圾的回收主要在堆内存中。







​	

