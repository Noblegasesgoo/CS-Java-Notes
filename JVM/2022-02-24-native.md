## 本地方法栈

本地方法栈（**`Native Method Stack`**）是线程私有的，他的具体做法是，在本地方法栈中登记我们的 **native** 方法，在 **Excution Engine** 执行的时候加载本地方法库，我们先来看一个问题：

- 一般我们所说的 java 中的栈，到底是指 **jvm 运行时数据区**中线程私有的 **java 栈**呢？还是 **jvm 运行时数据区**中线程私有的 **java 栈以及本地方法栈**呢？

但就是单指一个 **java 栈**，所以我们所说的本地方法栈，是一块独立的 **jvm** 内存区域。

**多线程是和操作系统有关？还是和 java 有关？**答案肯定是与操作系统有关。

**java** 中的 **`native`** 关键字，只要方法使用了 **`native`** 关键字修饰，那就代表着，这个方法不归 **java** 管了，**java** 只管调用就可以，而调用的是什么呢？调用的是底层操作系统或者 **C/C++** 语言编写的 第三方函数库。

==所以这个 JVM 中的本地方法栈以及 native 关键字，还有本地方法接口（Native Interface）他们之间的关系到底是怎么样的？==

我们通过一个类比来说明**本地方法栈的产生原因**，1995年的时候 **C 语言**是最顶级最厉害的语言，好比当时的世界最强国家，你想要在那个情况下混得好，那就必须和世界最强国家去打交道，去留余地，那么类比 **C 语言**，后来的所有语言要想混得好，那就得留有一块内存，可以和 **C 语言**调用，那么在 **java** 中这就是 **jvm** 内存模型的本地方法栈。

如果一个方法被 **`native`** 关键字修饰，那么它就进入**本地方法栈**去寻找，如果它没被 **`native`** 修饰，则进入 **java 栈**寻找。



## 本地接口

本地接口的作用是融合不同的编程语言为 **Java** 所用，它的初衷是为了融合 **C/C++** 程序，**Java** 诞生的时候是 **C/C++** 称霸的时候，要想立足，必须要调用 **C/C++** 程序，于是就在内存中专门开辟了一块内存区域处理标记为 **native** 方法，在 **Execution Engine** 执行时加载 **native libraries**。

目前该方法使用得越来越少了，除非是与硬件有关的应用，比如通过 **Java** 程序驱动打印或者 **Java** 系统管理生产设备，在企业级应用中已经比较少见了。因为在异构领域间的通信（比如微服务，我不管你另一个服务是什么语言编写的）很发达，比如可以使用 **Socket** 通信，也可以使用 **Web Service** 等等。 