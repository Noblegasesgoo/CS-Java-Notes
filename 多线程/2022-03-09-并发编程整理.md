#### 并发和并行有什么区别？

并行是指，多个处理器或者多核处理器同时执行处理多个任务，注意是同时执行。从CPU层面上来看，并发就是大量的任务在同一个CPU核上交替的按CPU提供的时间片运行。

举个栗子：

- 并行：两个打饭窗口，两个队（一个窗口一个有条理）。
- 并发：一个打饭窗口，两个队（交替）。

也就是说**并发这样的情况**如果是同时发生在**多个CPU核**上，那么就很有可能出现并行问题。

所以我们在使用多线程时：**考虑的一般都是，高并发环境下，程序内部可能发生并行执行而导致某些错误的问题**。



#### 线程和进程的区别？

- 进程是操作系统中执行的一段程序，线程是CPU调度资源的单位。
- 进程包含线程，类比我们的浏览器，他在操作系统层面就是一个进程，然后浏览器中的各个可以使用的设置就是浏览器这个进程中的线程。
- 一个进程可以有多个线程，一个线程对应一个进程。



#### 守护线程是什么？

我们用的最多的守护线程估计就是 JVM 的垃圾回收线程了，它在后台运行并且在满足一定条件下会进行垃圾回收，也可以按时回收。

所以守护线程，守护线程它是在后台运行的一种特殊进程，它能周期性的执行一些任务，独立于控制终端，也能等待处理某些发生的事件（垃圾回收）。

换句话来说，**守护线程它拥有能够结束自己生命周期的能力，直接进行一个我命由我不由天**。



#### 守护线程的作用？

我们拿 JVM 的垃圾回收线程来说，当我们的 JVM 要被关闭的时候，如果此时正在进行着垃圾回收，并且得持续一段时间，那么如果垃圾回收线程不是守护线程的话，整个 JVM 就得等到我们这个垃圾回收结束之后才能关闭。

但是**如果垃圾回收线程它是守护线程，那么它的垃圾回收和JVM关闭就类似于异步，你可以先走，我自己清理完了我自己走**。

也避免了有些时候 JVM 突然崩溃，但是内存中又有对象垃圾，这个时候守护线程就可以再 JVM 崩溃之后，独立的清理完毕这些垃圾然后自我销毁。



#### 线程创建有哪几种方式？

在 Java 中一共有四种：

- 继承 Thread 类，重写它的 run 方法。
- 实现 Runnable 接口。
- 实现 Callable 接口。
- 使用线程池。



#### sleep() 和 wait() 的区别？

- sleep 来自 Thread 类，wait 来自 Object；
- sleep 不会释放锁，wait 会释放锁；
- sleep 到期会自动苏醒，wait 得被主动叫醒。
- wait 只能在同步代码块中使用。



#### notify() 和 notifyAll() 有什么区别？

- 前者是由虚拟机叫醒一个线程，后者是全部叫醒。
- 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的**等待池**中，等待池中的线程**不会去竞争该对象的锁**。
- 当有线程调用了对象的 **notifyAll**()方法（唤醒所有 wait 线程）或 **notify**()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争
- 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它**还会留在锁池中**，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。



#### 请你解释一下 volatile？

volatile 是一个关键字，是一个轻量级的线程同步机制。

我们至少要答出两点：

- 它保证了可见性。
- 它保证了有序性，也就是禁止指令重排序。



#### 请你说一下 volatile 他是怎么保证可见性的？

首先，我们得了解 JMM 内存模型，因为一般情况下，我们的线程工作的内存环境都是基于 JMM 内存模型的，JMM 内存模型使每个线程有一个私有的工作内存，工作内存中的内容来自于主存，工作内存互相隔离互不干扰。

所以这样的内存模型的加持下，我们的可见性（变量之类的）在没有经过处理之前，它都是线程之间不可见的，所以我们这里说的可见性，就指的是，某个变量，要对所有先的线程可见。

但是，如果直接在工作内存层面来进行可见性的处理的话，是比较复杂的。

所以我们的 volatile 他是直接对被修饰的变量在主存中就直接禁止被线程复制到自己的工作空间中，让线程使用的时候，直接从主内存拿取，这样所有线程都得访问一个位于主内存中的变量，所以解决了不可见的问题。



#### volatile 具体是怎么保证可见的呢？

推送到主存的过程中会经过CPU数据总线，其它线程怎么可见呢？

- 最主要就是体现在 CPU 数据总线这个地方。
- **使用了CPU的总线嗅探技术，除了这个技术以外还是用了 MESI 缓存一致性协议，他们共同为 volatile 保证了可见性。**



#### CPU嗅探总线的过程中，它怎么知道 volatile 修饰的呢？

汇编层面的问题，当我们这个变量被 volatile 修饰，并且被一个线程修改要推到主存的过程，它对应的汇编指令码会在里面加一个 lock 指令。

这个 lock 指令，在汇编代码层面有两次含义：

- 将我们这条信息修改推送到主存。
- lock 指令过总线的时候，CPU 会嗅探带 lock 指令的汇编指令。



#### volatile 如何禁止指令重拍序呢？

首先我们要禁止的指令重排序是发生在编译阶段的，因为编译阶段，编译器会把我们的.java 文件的内容编译成JVM执行的指令，编译器的优化功能可能会按照它自己的逻辑打乱一些上下不相关的JVM的指令的执行顺序，这在单线程情况下是可以的，但是在多线程情况下，可能就会引发乱子。

所以我们多线程下要考虑的指令重排序，就是在编译阶段的指令重排序。volatile就是在这个阶段介入的。

那么 volatile 它做了什么？

它主要就是加了内存屏障：

- **volatile在写前加屏障**：**store-store** 写写不能进行重排序。
- **volatile在写后加屏障**：**store-load** 写读不能进行重排序。



- **volatile在读后加屏障**：**load-load** 读读不能进行重排序。
- **volatile在读后加屏障**：**load-store** 读写不能进行重排序（全能型屏障，开销大，基本不用）。



#### 说一说 volatile 对于原子性的理解？

**volatile 在特殊情况下是可以保证原子性的**，但是前提是在只有在**编译过后还是单条 JVM 指令的情况下**。

拿 **`i++`** 来说，之前反编译看过，它虽然是只有一条代码，但是 JVM 为其生成了三个指令，**`I LOAD，I ADD， I STORE`**我们的 **volatile** 此时它的作用域就只在 **`I LOAD`** 前面加 **store store 屏障**，在 **`I STORE`** 后面加 **store load** 屏障，**并不是每个步骤都加上了屏障**。

我们还是尽量不要回答到 JVM 指令，不然就是在给自己挖坑。



#### synchronized 关键字作用在不同的地方有什么区别？

**作用在普通方法上**：

- 他不是得new一个当前Class模板的类对象，才能调用，所以此时锁的就是这个对象

**作用在静态方法上**：

- synchronized 此时锁的是当前静态代码块所在类的Class，没错，就是你在方法区中的 Class 模板。
- 为什么是作用在 Class 上呢？因为，我们是不是直接可以通过类名来调用静态方法，而不需要我们去创建对象，这就意味着我们没对象可以锁了！那我们锁啥？
- 就只剩下了我们的 Class 。
- 那这个 Class 是从哪来的呢？他是经过java -c 编译之后，形成的二进制字节码文件，然后进行七步类加载过程，最终我们的.class 文件会放到方法区中，只不过它会从静态的二进制文件，转换为我们 JVM 虚拟机中的方法区的运行时数据文件，并且常量池会从静态常量池转化为运行时常量池，并且还要在堆里面为我们的 Class 开放一个入口，这个 Class 在这，也就是模板。

**作用在同步代码块上**：

- 我们可以指定锁，我们可以在成员变量中 new Object 作为锁，我们也可以用 this 关键字作为锁。



#### synchronized 和 volatile 到底有什么区别？

- 前者适用于写多读少，后者适用于写少都多的场景。
- volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。
- volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。



#### synchronized 和 Lock 有什么区别？

- 前者可以作用到方法上，后者只能所用在代码块上。
- 前者加锁解锁是隐式的，后者是显式的。
- 前者不需要手动释放，后者需要手动释放。
- 前者是 JVM 层面的，后者是编码层面的。
- 前者不可以知道有没有获取锁，后者可以知道。
- 前者是不公平锁，后者可以是公平也可以是非公平锁。
- 前者只能简单加锁，阻塞加锁，后者可以超时加锁，非阻塞加锁。







