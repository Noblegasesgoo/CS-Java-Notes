

## JMM



### 并发编程模型的分类

- 提出这些模型的原因是为了**解决线程（并发活动的执行体）之间如何通信以及线程之间如何同步**。
- 命令式编程之中，线程之间的通信机制有两种：共享内存、消息传递。
- **JAVA** 的并发采用的是**共享内存模型**，所以**JAVA**线程之间的通信是隐式进行的，整个通信的过程对于程序员来说是完全透明的！



#### 共享内存

- 线程之间共享程序的**公共状态**，**线程之间**通过**写-读内存中的公共状态来隐式的进行通信**。
- 在该模型中，线程同步是显式进行的，程序员**必须显式指定**某个方法或某段代码需要在线程之间互斥执行。



#### 消息传递

- 线程之间**没有公共状态**，**线程之间**必须**通过明确的发送消息来显式的进行通信**。
- 在该模型中，由于消息的发送必须在消息接收之前，所以同步是隐式进行的。



### Java 内存模型的抽象

- 局部变量、方法定义参数、异常处理参数都不会在线程之间共享，所以他们不会有内存可见性问题。
- **JAVA** 线程之间的通信由 **JAVA** 内存模型（**JMM**）控制。
- 同时他们也不受内存模型的影响。
- **JMM** 决定一个线程对共享变量的写入何时对另一个线程可见。
- 它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。



#### 堆内存

- 主要用来存储：**所有实例域、静态域、数组元素**。
- **堆内存**在线程之间是共享的。



#### 如何抽象

- 线程之间的共享变量存储在**主内存**之中。
- 每个线程都有对应的一个**私有本地内存**。
- 本地内存存储的是当前拥有这个本地内存的线程读写的**共享变量的副本**。



#### 如何通信

- 通过如下内存抽象模型来分析。
- 下图中 **A 线程**是如何和 **B 线程**通信的。
- 一：**线程 A** 把本地**内存 A** 中的共享变量副本更新到**主存**中。
- 二：**线程 B** 到**主存**中把之前 **A线**程更新过的共享变量读取出来。

![image-20211111200142439](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211111200142439.png)





## 应用的场景

- 我们现在并发主要用在两大块：
  - 图像处理。
  - 服务端程序，而我们**JAVA**一般都是开发服务端程序，所以绕不开**高并发**的学习以及使用。



## 管程

- **Monitor** 监视器，**Java** 中平时所说的 **锁**，就是**操作系统中所说的监视器**。
- 一种同步机制，保证同一时间，只有一个线程能够访问被保护的**临界区**。
- **JVM** 中进行同步操作，基于进入和退出 **Monitor** 对象来实现。



## 与并发有关的几个概念

- **同步**：同步的方法只要开始调用，调用者就必须等到**方法调用返回**才能继续进行后续的工作。
- **异步**：异步方法就不用等到**方法调用返回**就可以继续进行后续的工作。
- **并行**：同时执行。
- **并发**：看起来是同时执行，但其实是某一时段多个任务以极快的速度交替执行。



## 与共享资源有关的几个概念

- **临界区**：每个线程或进程访问临界资源的那段代码。

- **临界资源**：一种公共资源，可以被多个线程访问，但是一次只能一个线程访问。
  - 好比单间厕所，一旦有人使用，外面的人就得等着，等到这个人出来才能下一个人进去。
- **阻塞**：当一个线程占用了**临界区**的资源后，后续想要访问这个临界区的线程只能在这个临界区中等待，**等待会导致线程被挂起**，这就是阻塞。
- **非阻塞**：和阻塞不同，等待时线程不被挂起，而是一直尝试执行。



## 多线程活跃性的问题

- **死锁**：最不希望看到的情况，也就是最糟糕的情况，例如，A等B释放所需资源的同时B也等着A释放所需资源。
- **活锁**：线程之间互相让步，会在某些时刻主动释放资源。
- **饥饿**：一个或者多个线程因为一些原因无法获得当前所需的资源而导致其一直无法执行。
  - 就像线程或进程都有**优先级**的概念，一个**优先级高**的线程或进程一直在抢占并且使用资源，导致**优先级低**的线程或进程没法获得所需的资源导致饥饿。



## 并发级别

- 由于**临界区**的存在，我们必须对多线程之前对**临界区**的**并发访问**进行**控制**。
- 我们可以根据**并发的策略**，把并发级别分为五个级别：
  - **阻塞**、**无饥饿**、**无障碍**、**无锁**、**无等待**。
- **阻塞**：
  - **悲观策略**，一个线程占用临界资源，其它线程就需要挂起等待，无法继续执行下去，比如在 **JAVA** 中的 **synchronized** 或者是 **重入锁**。
- **无饥饿**：
  - **悲观策略**，阻塞调度，进程或进程之间有优先级的概念，按照**优先级**来进行线程或进程的调度，这也会产生**优先级低**的进程或线程产生饥饿。
  - 我们可以通过锁是公平的，按照先来后到的规则进行线程调度。
- **无障碍**：
  - **乐观策略**，非阻塞调度，不同的线程都可以进入临界区，读线程可以随意读，但是写线程得判断当前资源有没有发生竞争，也就是有没有中途被别的线程修改，如果修改了就进行**回滚**。
- **无锁**：
  - 解决了无障碍并发级别的缺点。
  - 通过**无障碍加一致性标志**来实现。
  - 在修改资源之前先保存这个标记，再修改数据。
  - 修改完数据之后，我们再看看先前的标志有没有被别的线程篡改，如果是被篡改过，那就说明，发生了资源的争抢，此时就得判断是回滚还是沿用。
  - 保证至少有一个线程可以走出**临界区**。
  - 一般我们通过**do-while**循环来判断，判断用的 **compareAndSet** 方法，本质是 **CAS** 语句。

- **无等待**：
  - 无锁级别的改进。
  - 因为无锁级别并发只是要求一个线程可以在有限步内完成操作，而无等待要求所有的线程都必须在有限步内完成。
  - 无等待可以根据 **do-while** 循环次数来进一步分解为俩种无等待类型：
    - 有界无等待和线程数无关的无等待。
  - 应用：**RCU结构(Read Copy Update)**。
    - 所有的读线程都是无等待的，也就是说它们既不会被锁定等待也不会引起任何冲突。
    - 写线程拥有原始数据的副本，接着只修改副本数据，修改完副本数据后会在合适的时机回写数据。









## JAVA内存模型（JMM）中多线程的AVO



### JMM

- 它并不是真实存在的，它描述的是**一组规范或者说是规则**。
- 通过这组规范定义了程序中的各个变量（包括实例字段、静态字段和构成数组对象的元素）的**访问方式**。

| ![image-20211111220125651](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211111220125651.png) |
| :----------------------------------------------------------: |
|                       JMM内存模型图示                        |



### JMM关于同步的规定

- 线程解锁前：必须把**共享变量**的值刷新回主存。
- 线程加锁前：必须读取主存中最新的**共享变量**的值到自己的工作内存中。
- 加锁和解锁的锁是同一把锁。



### 主内存

- 相当于堆内存。
- 这个主内存不是**JAVA虚拟机**的而是**硬件上的内存条**的内存。



### 工作内存

- 相当于栈内存。
- 但是他有指向堆内存的指针。



### 原子性

- 即一个操作是不可中断的，和事务类似。
- **JAVA**中：
  - 所有引用类型的复制操作。
  - 除了**long**和**double**类型意外的基本类型赋值操作（32位）。
  - **java.concurrent.Atomic.*** 包中所有类的一切操作。



### 可见性

- 并发环境下，一个线程修改了一个共享资源，其它线程能够立马就知道这个变量被修改过了。
- ==可见性指每次读取值的时候可见==，**通过ABA问题可以推断，它的通知时间为一次原子操作之后，才会重新读取主内存中的值来保持可见性。**
- 可见性是一个综合性问题：
  - **内存的读写操作不会立即执行**，而是会先进入一个硬件队列等待，当然，我们也可以通过设置 **volatile** 来修改直接写进内存，而不是写入缓存。
  - 还有指令重排以及编译器优化。



### 有序性

- **JMM** 是允许编译器和处理器对指令进行重新排序的，**但不管怎么重新排序，程序允许的结果是不能改变的**！
- 指令重排的前提是串行语意的一致性，不能保证多线程的语意也一致。
- 不能重排的指令：
  - **volatile** 规则：**volatile** 修饰的变量的写比读先发生，这保证了 **volatile** 变量的可见性。
  - 传递性：**A -> B -> C**，**A** 必定先于 **C** 发生。
  - 线程的 **start** 方法先于它的每一个操作。
  - 线程的所有操作都在线程的终结之前。
  - 线程的中断比被中断线程的代码先进行。
  - 对象的构造函数执行和结束都在 **finalize** 方法之前。
  - 锁规则：解锁必然发生在加锁之前。



## 内存屏障



### 什么是内存屏障

- **内存屏障**，又称**内存栅栏**，是一个**CPU**指令，它可以保证**特定操作的执行顺序**。



### 作用

- 保持**特定操作的执行顺序**。
- 保证某些变量的**内存可见性**，刷新**CPU**缓存，强制刷出各种**CPU**的缓存数据到主内存中，所以任何当前**CPU**上的线程都可以拿到最新的数据。
- **volatile**关键字就是利用该特性实现的内存可见性。



### 如何作用

- 编译器和**CPU**都可以对指令进行重排序。
- 我们在指令之间插入一条**内存屏障**则会告诉编译器和**CPU**，此时**不管什么指令都不能和这条内存屏障指令进行重排序**。
- 通俗来讲就是通过插入内存屏障来禁止**CPU或编译器**对**内存屏障前后的指令进行重排序优化**。



### 作用场景

| ![image-20211112175340686](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211112175340686.png) |
| :----------------------------------------------------------: |
|                           作用场景                           |



#### 场景一：对volatile变量进行写操作

- 对**volatile**变量进行写操作。
- 会在写操作后面插入一条 **store** 屏障指令，将工作内存中的共享变量值刷新回到主内存。



#### 场景二：对volatile变量进行读操作

- 对volatile变量进行写操作。
- 会在读操作之前加入一条 load 屏障指令，从内存中读取共享变量。



## 重排序

- **JAVA**的源代码到最终实际执行的指令顺序，会经历以下三种重排序。
- 指令重排序只会保证**串行语义的执行的一致性**（**单线程下**），并不关系**多线程并发状态下的语义一致性**。

![image-20211111201154430](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211111201154430.png)



### 编译器优化的重排序

- 是指编译器在**不改变单线程程序语义的前提下**，重新安排语句的执行顺序。
- 处理器在进行重排序的过程中必须要考虑指令之间的数据依赖性。
- 多线程环境中线程交替执行，由于**编译器优化重排指令**的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测。

```java
int a = 0;
int b = 0;
// 重排之后可能变成，他们之间没有数据依赖性，所以谁先谁后没问题。
int b = 0;
int a = 0;
```

```java
int a = 0;
int b = 0;
int c = a + b;
// a 和 b 之间没有数据依赖性，但是 c 依赖于 a 和 b。
// 重排之后 c 永远是在 a 和 b 之后被执行的。
int b = 0;
int a = 0;
int c = a + b;
```

- 编译器指令重排是一回事，==可能线程之间切换也会有不同的情况产生，我们不讨论这个==。



### 指令级并行的重排序

- 现代处理器采用 ILP（指令级并行技术）来进行多条指令重叠执行。
- 如果数据之间没有依赖性，那么处理器可以改变语句对应的机器指令的执行顺序



### 内存系统的重排序

- 由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。



## volatile



### 什么是volatile

- **volatile**是**Java**虚拟机提供的一种轻量级的同步机制。
- 三大特性：
  - ==保证了可见性，但不保证原子性，禁止指令重排序==。
  - 从主内存同步工作内存。
- 满足了**JMM**规范的可见性，有序性，但是不保证原子性。



### 什么情况下使用



##### 不必要的编译器重排序情况

- 线程之间变量**有数据依赖性**。

| ![image-20211112171239029](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211112171239029.png) |
| :----------------------------------------------------------: |
|               不必要的编译器重排序情况下的案例               |

- 从上述例子我们可以看出，如果我们就想要**编译重排**之前的效果，但是**编译重排之后**数据结果不一致。
- 这时我们需要使用 **volatile** 关键字禁止指令重排，以确保在**并发环境**下发生结果不一致的情况。



### 验证volatile关键字的可见性案例



#### 测试内容

- 资源类

```java
class MyData {

    private int number = 0;

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }
}

class MyDataVolatile {

    private volatile int number = 0;

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }
}
```

- 主线程

```java
package JUC;

import java.util.concurrent.TimeUnit;

/**
 * @author zhaolimin
 * @date 2021/11/12
 * @apiNote 测试volatile可见性。
 */

public class VolatileDemo01 {
    /**
     * 可以保证可见性，及时通知其它线程物理内存的值被修改。
     */
    public static void visibility(){
        /*
            假如 number 没有被 volatile 关键字修饰。
         */

        // 新建资源类
        MyData myData = new MyData();
        MyDataVolatile myDataVolatile = new MyDataVolatile();

        new Thread(() -> {

            System.out.println(Thread.currentThread().getName() + "\t come in");

            // 线程创建后进入让当前线程等待三秒钟，这样做确保其它线程也可以取到最初的共享资源的值。
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            myDataVolatile.setNumber(10);
            System.out.println(Thread.currentThread().getName()+ "\t update number succeed to " + myDataVolatile.getNumber());

        }, "Thread-A").start();

        // 第二个线程我们就不 new 新的了，就用 main 线程。
        // 如果共享资源没被更改就一直循环等待。
        while (myDataVolatile.getNumber() == 0) {

            // 这里加上 sout 语句的话也会刷新 number 的值。
            //System.out.println(Thread.currentThread().getName()+"\t checking。。。");
            //System.out.println("number is :" + myData.getNumber());

        }

        System.out.println(Thread.currentThread().getName() + "\tcheck succeed!" + "number is : " + myDataVolatile.getNumber());
    }

    public static void main(String[] args) {
        visibility();
    }
}

```



### 验证volatile不保证原子性的案例



#### 测试内容

- 资源类

```java
// 虚拟机读取过程：MyTest01.java -》 MyTest01.class -> JVM字节码 
class MyTest01 {

    // 添加了 volatile 关键字。
    private volatile int number = 0;

    public int getNumber() {
        return number;
    }

    public void autoIncreased() {
        // ++操作是不能保证原子性的，但是JUC中有对应的数据类型可以保证++操作的原子性。
        number ++;
    }
}
```

- 主线程

```java
package JUC;

/**
 * @author zhaolimin
 * @date 2021/11/12
 * @apiNote volatile 原子性测试。
 */

public class VolatileDemo02 {

    public static void main(String[] args) {

        // 资源类
        MyTest01 myTest01 = new MyTest01();

        // 20个线程
        for (int i = 0; i < 20; i++) {

            // 每个线程对 number 资源进行 ++ 操作1000次
            new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    myTest01.autoIncreased();
                }
            }, String.valueOf(i)).start();

        }

        // 正常情况，如果确保了原子性，那么，我们的 number 最终的值应该是 1000 * 20 = 20000 才对
        // 我们在等上面的循环执行完成之后我们再用 main 线程查看此时 number 的数量是不是和预期结果相等

        // 默认单线程情况下，后台只有两个线程，一个是主线程，一个是GC线程。
        while (Thread.activeCount() > 2) {
            Thread.yield(); // 挂起线程。
        }

        System.out.println(Thread.currentThread().getName() + " 最终测试结果 number = " + myTest01.getNumber());
    }

}

```

- 测试结果并不一定是预期的 **20000** ，而是随机的数。



#### 造成原因

- 就拿上面的案例来说。

| ![image-20211112135436529](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211112135436529.png) |
| :----------------------------------------------------------: |
|                             图示                             |

- 1、所有线程获得 **number** 的一份副本。
- 2、所有线程都进行了 **++ 操作**，此时 **number** 在线程的各自工作内存中值都为 **1**。
- 3、**线程 A** 将其**工作内存**中的 **number** 的值写入主存的过程中突然被**挂起**。
- 4、此时 **线程 B** 获得 **CPU 调度**，进行了**主存回写**，主存中 **number** 此时就为**1**了。
- 5、此时 **线程 A** 解除了挂起状态。
- 6、由于 **volatile** 的**禁止指令重排序**的原因。
- 7、导致虽然 **number** 此时对于其它线程是**可见的**，但是此时不能进行**指令重排序**，重新读取**主内存**中**最新的值**去**重新进行 ++ 操作**。
- 8、当执行**++**的过程中, 即使知道变量被修改也只能硬着头皮执行完++的全部步骤, 不能中断下来重头读取。
- 9、主内存中 **number** 在**线程 A** 写回操作后，本该为 **2** ，可是由于指令重排序，此时是将 **number** 的值覆盖为了 **线程 A 工作内存**中的值。
- 10、此时的操作可以看作，正确执行后应该是 **number = number + 1**；现在错误执行后是 **number = 1**。



#### 对 ++ 操作 的字节码解析

- 这里面每一个字节码都是原子操作，但是一个 **++ 操作**对应4个字节码操作，对于这**4个字节码层面，它不可保证原子性。**

- 可能某个线程到 **putfield** 的时候就被挂起了，然后禁止指令重排序，所以即使在当前线程被唤醒后通过**可见性**得知了主内存中值被更改，但是此时也不能掉头去重写读取再写回了，因为**禁止指令重排序**。

| ![image-20211112140914651](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211112140914651.png) |
| :----------------------------------------------------------: |
|                             图示                             |



#### 解决方法

##### 方法一

- 加 **synchronize** 关键字，但是不建议杀鸡用宰牛刀。

##### 方法二

- 用 **JUC** 下的原子类包中的 **AtomicInteger** 来替换基本数据类型 **int** 的使用。
- 改动后的资源类

```java
class MyTest01 {

    // 添加了 volatile 关键字
    private volatile int number = 0;

    public int getNumber() {
        return number;
    }

    public void autoIncreased() {
        // ++操作是不能保证原子性的，但是JUC中有对应的数据类型可以保证++操作的原子性
        number ++;
    }

    // 它的源码中默认的 value 是被 volatile 修饰过的，所以我们在这里不用修饰
    AtomicInteger atomicInteger = new AtomicInteger();

    public void autoIncreasedAtomicInteger() {
        // 原子类类似 i++ 的方法
        // 相当于atomicInteger.getAndAdd(1);
        atomicInteger.getAndIncrement();
    }

}
```

- 主线程

```java
package JUC;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author zhaolimin
 * @date 2021/11/12
 * @apiNote volatile 原子性测试。
 */

public class VolatileDemo02 {

    public static void main(String[] args) {

        // 资源类
        MyTest01 myTest01 = new MyTest01();

        // 20个线程
        for (int i = 0; i < 20; i++) {

            // 每个线程对 number 资源进行 ++ 操作1000次
            new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    myTest01.autoIncreased();
                    myTest01.autoIncreasedAtomicInteger();
                }
            }, String.valueOf(i)).start();

        }

        // 正常情况，如果确保了原子性，那么，我们的 number 最终的值应该是 1000 * 20 = 20000 才对
        // 我们在等上面的循环执行完成之后我们再用 main 线程查看此时 number 的数量是不是和预期结果相等

        // 默认单线程情况下，后台只有两个线程，一个是主线程，一个是GC线程。
        while (Thread.activeCount() > 2) {
            Thread.yield(); // 挂起线程。
        }

        System.out.println(Thread.currentThread().getName() + " 基本类型int，最终测试结果 number = " + myTest01.getNumber());
        System.out.println(Thread.currentThread().getName() + " 原子类包装AtomicInteger，最终测试结果 number = " + myTest01.atomicInteger);
    }

}
```



##### 方法三

- CAS操作来控制。



## 线程安全性获得保证

- 工作内存与主内存之间同步存在延迟导致的可见性问题。
  - 我们可以使用 **synchronized** 或 **volatile** 关键字解决，他们都会使一个线程修改变量过后，该变量立即对其它线程可见。
- 对于指令重排导致的可见性和有序性问题。
  - 我们可以使用 **volatile** 关键字解决，**volatile** 关键字可以禁止指令重排序，不是实现指令重排序。





## 单例模式在并发环境下可能出现的问题



### 标准懒汉式单例模式

- 会出现多个实例，违背了单例模式原则。

```java
package JUC;

/**
 * @author zhaolimin
 * @date 2021/11/12
 * @apiNote 单例模式在并发环境下可能出现的问题。
 */

// 先写一个懒汉式单例模式。
public class SingletonDemo01 {

    private static SingletonDemo01 singletonDemo01 = null;

    private SingletonDemo01() {
        System.out.println(Thread.currentThread().getName() + "\t 我是构造方法SingletonDemo01()");
    }

    private static SingletonDemo01 getSingletonDemo01(){

        if (singletonDemo01 == null) {
            singletonDemo01 = new SingletonDemo01();
        }

        return singletonDemo01;
    }

    public static void main(String[] args) {
        // 并发环境
        for (int i = 0; i < 10; i++) {

            new Thread(() -> {
                SingletonDemo01.getSingletonDemo01();
            }, String.valueOf(i)).start();
        }
    }
}

```



#### 解决方法

- 对象创建的过程会出现**指令重排**，可能导致**多线程读取到的对象为半初始化的对象**。
- 先分配了内存地址，但是此时初始化并没有完成就将对象返回了。
- 我们得防止创建实例的时候**指令重排**，从而让别的线程拿到了**不完整的实例**。
- 因为 **new** 不是原子操作，一般是三步：
  - **分配内存空间 -> 初始化对象 -> 设置指针将对象指向内存地址**。
  - 第二步与第三步是不存在**数据依赖关系**，所以可以打乱在单线程情况下不会有什么大的问题，但是在并发环境下可能就会出现问题。



##### 添加 synchronized 关键字

- 在 **getSingletonDemo01** 方法上添加 **synchronized** 关键字同步。
- 但是性能低。
- 没解决重排序的问题。

```java
private static synchronized SingletonDemo01 getSingletonDemo01(){    
    if (singletonDemo01 == null) {        
        singletonDemo01 = new SingletonDemo01();    
    }    
    return singletonDemo01;
}
```



##### DCL模式

- **Double Check Lock 双重检测锁模式**。
- 进来和判断前，进来和进来后，分别判断两次。
- 因为指令重排序问题，不保证百分百的正确性。

```java
private static SingletonDemo01 getSingletonDemo01(){    
    if (singletonDemo01 == null) {                
        synchronized (SingletonDemo01.class) {            
            // 防止创建2次实例，这里是单例模式            
            if (singletonDemo01 == null) {                
                singletonDemo01 = new SingletonDemo01();            
            }          
        }    
    }    
    return singletonDemo01;
}
```



##### DCL模式+volatile

- **DCL**模式已经将问题范围缩小到指令重排上。
- 所以我们加一个 **volatile** 关键字在它的变量上来禁止指令重排，来保证并发环境下的语义一致性。

```java
private static SingletonDemo01 getSingletonDemo01(){    if (singletonDemo01 == null) {                synchronized (SingletonDemo01.class) {                        if (singletonDemo01 == null) {                singletonDemo01 = new SingletonDemo01();            }          }    }    return singletonDemo01;}
```



## 什么是CAS操作

-  通俗来讲就是**比较并交换**（Compare And Swap）。	
-  是一条**CPU并发原语**。
-  他是判断**内存某个位置**的值**是否为预期值**，如果是则更改为新值，否则线程不挂起，持续比较到**主内存**与**工作内存**中的值一致为止。
-  **整个执行过程**都是满足**原子性**的。



## 为什么不会造成数据不一致

- **CAS**操作体现在Java语言之中就是 **Unsafe类** 中的各个方法。
- 调用 **Unsafe类** 中的**CAS**操作，JVM 会帮我们实现出 **CAS的汇编指令**。
- 这是一种完全依赖于**硬件**的功能，通过它实现**原子操作**。



- **实现逻辑**上来说就是：
  - **CAS**是**系统原语**。
  - 原语属于操作系统用语范畴。
  - 若干条操作系统指令构成，用于完成某个功能的一个过程。
  - 原语的执行必须是连续的，执行过程中不能被中断。
  - CAS指令是一条CPU原子指令。
  - 所以不会导致数据不一致问题。



## 案例演示



### 演示用到的关键方法

- **compareAndSet** 方法：
- 参数一：期望值，主存中的值。
- 参数二：更新值。

```java
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```



### 单线程中

```java
package JUC;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author zhaolimin
 * @date 2021/11/13
 * @apiNote CAS测试
 */
public class CASDemo01 {

    public static void main(String[] args) {
        

        AtomicInteger atomicInteger = new AtomicInteger(10);

        System.out.println(atomicInteger.compareAndSet(10, 2021) + "\t 当前atomicInteger在主内存中的值为：" + atomicInteger.get());
        // 第三条语句，已经 atomicInteger 被修改为 2021 了与期望值 10 不一样，所以修改不了。
        System.out.println(atomicInteger.compareAndSet(10, 2022) + "\t 当前atomicInteger在主内存中的值为：" + atomicInteger.get());
    }
}

```

- 1、此时主内存中，**atomicInteger** 的值为**10**。
- 2、我们使用 **CAS操作** 开始准备对主存中 **atomicInteger** 的值的更改。
  - 2.1、**compareAndSet**方法第一个参数为 **expect** 期望值，我们期望主存中的 **atomicInteger** 的值为**10**的时候更改，所以这里第一个参数传入**10**。
  - 2.2、第二个参数是想要更改的值，我们此时将 **2021** 设置为 **atomicInteger** **更改后的值**。 
  - 2.3、如果此时我们传入的期望 **atomicInteger** 的值与主内存中 **atomicInteger** 的值一样，就进行 **10 -> 2021** 的更改，否则就自旋不做任何操作。



### 多线程中

```java
package JUC;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author zhaolimin
 * @date 2021/11/13
 * @apiNote CAS测试
 */
public class CASDemo01 {

    public static void main(String[] args) {

        AtomictoInteger atomicInteger = new AtomicInteger(10);

        //System.out.println(atomicInteger.compareAndSet(10, 2021) + "\t 当前atomicInteger在主内存中的值为：" + atomicInteger.get());
        //System.out.println(atomicInteger.compareAndSet(10, 2022) + "\t 当前atomicInteger在主内存中的值为：" + atomicInteger.get());

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " " + atomicInteger.compareAndSet(10, 2021) + "\t 当前atomicInteger在主内存中的值为：" + atomicInteger.get());
            }, String.valueOf(i)).start();
        }

        System.out.println(Thread.currentThread().getName() + " " + atomicInteger.compareAndSet(10, 2022) + "\t 当前atomicInteger在主内存中的值为：" + atomicInteger.get());
    }
}
```

- 和单线程的过程一样。



## Unsafe类



### 这个类是什么

- 存在于 `rt.jar\sun\misc\Unsafe.class` 。
- 是**CAS操作**的核心类。
- **Java**方法没有办法**直接访问底层系统**，需要通过**本地原生方法**来访问，**Unsafe** 类相当于一个后门，基于该类可以**直接操作特定内存的数据**，就像**C/C++**的**指针**一样**直接操作内存**，**Java**中的**CAS操作**依赖于**Unsafe**类的方法。
- ==该类中所有方法都是原生方法==，换句话说就是该类中的方法都是直接调用**操作系统底层资源**执行相应的任务。
- 该类中所有方法的执行都使用了**汇编指令**，**汇编指令**的执行是**原子的**，可以保证**操作的原子性**。



### 它是怎么操作内存中的对象的

- 靠 **valueOffset** 要操作对象的内存地址偏移量来操作。



### 用AtomictoInteger类来说明

#### 该类的重要属性以及静态代码块

```java
// 获得 Unsafe 类的对象
private static final Unsafe unsafe = Unsafe.getUnsafe();
// 内存地址偏移量，当前对象在主内存中的内存偏移量
private static final long valueOffset;
// 该类存储的值
private volatile int value;

static {
    try {
        // 得到当前对象在主内存中的地址偏移量
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField("value"));
    } catch (Exception ex) { throw new Error(ex); }
}
```



#### 我们先来看看这个类中的getAndIncrement方法的调用（重点）

```java
public final int getAndIncrement() {
    /*
    	this：当前对象在内存中的起始地址
    	valueOffset：内存地址偏移量，当前对象在主内存中的内存偏移量
    	i：操作值
    */
    // 这个this和valueOffset理解可能有点困难，简单来讲就是，
    // this是指当前原子类对象，valueoffset 是指原子类对象里，变量 value 在 this内存区块 中的地址偏移量
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```

```java
public final int getAndAddInt(java.lang.Object o, long l, int i) { /* compiled code */ } 
```

```java
/**
	var1：当前对象，起始地址
	var2：当前对象在主内存中的内存偏移量
	var4：操作值
*/
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        // var5 就是当前this所指对象在内存中的地址加上当前对象内存偏移量在内存中存值的实际地址的值
        var5 = this.getIntVolatile(var1, var2); 
        // 不是期望值就会一直循环，等待 var5 与预期值对应上再修改，修改完毕再跳出。
        // 是期望值就接着+var4，直到最外面的循环结束
    } while (!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    return var5;
}
```

```C++
// 先想办法获取变量 value 在内存中的地址。
// 通过 (Atomic::cmpxchg(x,addr,e)) 方法实现比较替换。
UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env,jobject unsafe,jobject objm jlong offset,jint e,jint x))
UnsafeWrapper("Unsafe_CompareAndSwapInt")  ;
opp p = JNIHandles::resolve(obj);
jint* addr = (jint*) index_opp_from_field_offset_long(p, offset);
return (jint)(Atomic::cmpxchg(x,addr,e)) == e;
UNSAFE_END
```





#### 思考

- 为什么不用 **synchronized**关键字 而是 **CAS操作**？
  - **synchronized** 需要**切换线程的状态**，并且需要**信号量**和**监视器**。
  - **synchronized** 同一时间段只允许一个线程来访问，**一致性**得到了保证，但是**并发能力下降**。
  - CAS操作 没有上述难题，但是**很费CPU资源**。
- 如果只是操作原子，**只是单核中不可被打断**，但是多核可以同时进行，**A线程**在**一个核修改**，**B线程**在**另一个核同时修改**怎么办？
  - 因为其实在调用这个原子性的**CPU**指令**compareAndSwap**之前会**判断是否是多核状态**，是多核就再上一个**总线锁**，**多核CPU**就只能有**一个核能通过总线访问内存，这一个核执行完才能另一个核**。



## CAS的缺点



### 循环时间长开销大

- **CAS操作**由于**线程不会被挂起**，**CAS失败**的话会一直**自旋等待**尝试，所以**高并发**下如果多个线程都在**自旋等待**，那么会很**耗CPU资源**。



### 只能保证一个共享变量的原子操作

- 对于**多个共享变量**的操作，**CAS**就**无法保证操作的原子性**。
- 这个时候就可以用**锁**来协同保证**操作的原子性**。



### 引出ABA问题



## ABA问题



### 什么是ABA问题

- CAS乐观锁操作实现的一个重要前提就是需要取出内存中某时刻的数据并在当下时刻比较并替换，那么再这个时间差之间会导致数据的变化。



### 如何产生（重点）

- 假设有**三个线程**，**共享资源的值为B**。
- **线程A、B、C**分别拷贝了一份到了自己的**工作内存**中。
- **线程A**的期望值是**B**，**线程B**的期望值是**B**，**线程C**的期望值是**A**。
- 原子操作运行世间：**B>C>A**。
- **线程B**此时先将共享资源的值设置为了**A**并写回主存，与**线程C**预期值正好相同为**A**。
- **线程C**又将**A**改为**B**写回主存。
- ==由于线程阻塞的原因，可见性指每次读取值的时候可见，这里线程A第二次还没有读取值，也就是一次操作之间虽然是原子操作，但是操作的时间有长有短，线程A是最长的，在这次多核操作中，线程A的原子操作还没有完成，线程B和C的就已经完成了。还没到可见性的地步。==
- 由于以上原因，此时**线程A**它依旧以为**主存中的值与它原子操作进行时的期望值一样**，可实际上已经被**线程B**和**线程C**操作过了。
- 所以此时尽管**线程A**的**CAS**操作时成功的，但是不代表这个过程就是正确的。

```java
package JUC;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;/** * @author zhaolimin * @date 2021/11/13 * @apiNote ABA问题的解决 */public class ABADemo {    static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);    public static void main(String[] args) throws InterruptedException {        // 假的ABA模拟        // 暂停线程来模拟线程原子操作速度不一致问题        // 例子不太对，线程 T3 应该在T1、T2修改之前就读到了100        new Thread(() -> {            System.out.println(atomicReference.compareAndSet(100, 101) + "\t" + Thread.currentThread().getName() + "\t" + atomicReference.get());        }, "T1").start();        // t2 线程暂停一秒        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -> {            System.out.println(atomicReference.compareAndSet(101, 100) + "\t" + Thread.currentThread().getName() + "\t" + atomicReference.get());        }, "T2").start();        // t3 线程暂停三秒        try {            TimeUnit.SECONDS.sleep(3);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -> {            System.out.println(atomicReference.compareAndSet(100, 2000) + "\t" + Thread.currentThread().getName() + "\t" + atomicReference.get());        }, "T3").start();    }}
```

```java
/*    true	T1	101    true	T2	100    true	T3	2000*/
```

- 为什么如果改成**128**或者**-129** 再用这个**128**或者**-129**作期望值会CAS失败？
  - **Integer**常量池默认是**-128 ~ 127**，**AtomicReference**对于**Integer**类**超过128**会创建一个**新的对象**而**不使用缓存**所以导致数据无法添加成功 。
  - 所以导致**主物理内存中的Integer值**与**工作内存中的Integer值**不一致。



## 解决ABA问题

- 原子引用 + 原子引用版本号（类似于时间戳）。

```java
// T1	100 1 		    200 2	200 3// T2	100 1	200 2	100 3// 版本号不一致，以最新的为准，T1回滚重读主内存再更改
```



### AtomicReference原子引用

- 为了给**引用类型变量**也提供**CAS**操作，我们JUC提供了**原子引用包装类**。

```java
package JUC;import java.util.concurrent.atomic.AtomicReference;/** * @author zhaolimin * @date 2021/11/13 * @apiNote 源自引用测试。 */class User {    String username;    int age;    public User(String username, int age) {        this.username = username;        this.age = age;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return "User{" +                "username='" + username + '\'' +                ", age=" + age +                '}';    }}public class AtomicReferenceDemo {    public static void main(String[] args) {        User zlm = new User("zlm", 21);        User wl = new User("wl", 20);        AtomicReference<User> userAtomicReference = new AtomicReference<User>();        userAtomicReference.set(zlm); // 主内存中的共享变量        System.out.println(userAtomicReference.compareAndSet(zlm, wl) + "\t" + userAtomicReference.get().toString());        System.out.println(userAtomicReference.compareAndSet(zlm, wl) + "\t" + userAtomicReference.get().toString());    }}
```



### AtomicStampedReference版本号原子引用

- 解决了**ABA**问题。

```java
package JUC;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.atomic.AtomicStampedReference;/** * @author zhaolimin * @date 2021/11/13 * @apiNote ABA问题的解决 */public class ABADemo {    static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);    static AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(100,1);    public static void main(String[] args) throws InterruptedException {        // 假的ABA模拟        // 暂停线程来模拟线程原子操作速度不一致问题。        new Thread(() -> {            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + "\t第一次版本号：" + stamp);            // t1 线程暂停一秒，确保 t2 线程能够拿到最初的版本号            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(atomicStampedReference.compareAndSet(100, 101,                    atomicStampedReference.getStamp(),                    atomicStampedReference.getStamp() + 1) + "\t" + Thread.currentThread().getName() + "\t");            System.out.println(Thread.currentThread().getName() + "\t当前版本号：" + atomicStampedReference.getStamp());            System.out.println(atomicStampedReference.compareAndSet(101, 100,                    atomicStampedReference.getStamp(),                    atomicStampedReference.getStamp() + 1) + "\t" + Thread.currentThread().getName() + "\t");            System.out.println(Thread.currentThread().getName() + "\t当前版本号：" + atomicStampedReference.getStamp());        }, "T1").start();        new Thread(() -> {            int stamp = atomicStampedReference.getStamp();            System.out.println(Thread.currentThread().getName() + "\t第一次版本号：" + stamp);            // t2 线程暂停三秒，确保 t1 线程能够进行假ABA操作            try {                TimeUnit.SECONDS.sleep(3);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + "\t 目前使用的版本号是：" + stamp);            System.out.println(atomicStampedReference.compareAndSet(100, 2000,                    stamp,                    stamp + 1) + "\t" + Thread.currentThread().getName() + "\t");            System.out.println(Thread.currentThread().getName() + "\t当前实际版本号：" + atomicStampedReference.getStamp());            System.out.println("\t当前实际最新值：" + atomicStampedReference.getReference());        }, "T2").start();    }}
```

```java
/*    T1	第一次版本号：1    T2	第一次版本号：1    true	T1	    T1	当前版本号：2    true	T1	    T1	当前版本号：3    T2	 目前使用的版本号是：1    false	T2	    T2	当前实际版本号：3        当前实际最新值：100*/
```

- 我们可以看出，即使**期望值一样**，但是**版本号没有对应上**，这样也**没办法成功修改主内存中的值**。



## ArrayList线程不安全



### 案例

```java
package JUC;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * @author zhaolimin
 * @date 2021/11/13
 * @apiNote ArrayList类不安全测试
 */

public class ArrayListNotSafeDemo {

    public static void main(String[] args) {

        List<String> list = new ArrayList<>();
        for (int i = 0; i < 50; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
        // java.util.ConcurrentModificationException 出现了快速失败机制
    }
}

```



### 故障现象

- 抛出 ==java.util.ConcurrentModificationException== 出现了并发修改期望值与修改值不同，快速失败机制。



### 故障原因

- 多线程添加操作下，出现了快速失败机制。
- 原因是**add**方法对于**ArrayList**来说是线程不安全的。
- 并发争抢修改导致的问题，一个线程正在写，另一个线程抢夺，导致**数据不一致**问题。



### 解决方案



#### 将ArrayList类换成Vector类

- 可以解决，但是并发性急剧下降。

```java
 public static void main(String[] args) {

        List<String> list = new Vector<>();
        for (int i = 0; i < 50; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
```



#### 运用集合工具类Collections



##### Collections.synchronizedList方法

- 可以解决，但是并发性急剧下降。

```java
   public static void main(String[] args) {

        List<String> list = Collections.synchronizedList(new ArrayList<>());
        for (int i = 0; i < 50; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
```



#### 运用JUC下的CopyOnWriteArrayList类（重点）

- 主要用于**读多写少**的场景。
- **写时复制**：
  - **读的是原数组，锁的是副本**。
  - **一般来说读写不能并发，但使用写时复制的话，就允许了，提高了并发能力**。
- **缺点**：
  - **典型的空间换取时间**。
  - **会产生大量无效的对象引用碎片**。

```java
    public static void main(String[] args) {
        
        List<String> list = new CopyOnWriteArrayList<>();

        for (int i = 0; i < 50; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
```



##### CopyOnWriteArrayList类核心内容选读

- 与添加有关的方法

```java
/**
	追加一个特殊的元素到这个List集合的尾部。
*/
public boolean add(E e) {
    // 用 ReentrantLock 加锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    // 注：JDK9以后已经改为 synchronized 加锁了。
    try {
        // 拿到旧表
        Object[] elements = getArray();
        // 拿到旧表的长度
        int len = elements.length;
        // 在旧表的基础上拷贝并长度 + 1 新表
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 在新表的末尾追加要添加的元素
        newElements[len] = e;
        // 将当前表设置为新表
        setArray(newElements);
        // 返回添加成功
        return true;
    } finally {
        // 解锁
        lock.unlock();
    }
}
```





## HashSet线程不安全



### 案例

```java
package JUC;

import java.util.HashSet;
import java.util.UUID;

/**
 * @author zhaolimin
 * @date 2021/11/14
 * @apiNote HashSet线程不安全测试。
 */
public class HashSetNotSafeDemo {

    public static void main(String[] args) {

        HashSet<String> strings = new HashSet<>();

        for (int i = 0; i < 50; i++) {
            new Thread(() -> {
                strings.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(strings);
            }, String.valueOf(i)).start();
        }
    }
}
```



### 故障现象

- 抛出 ==java.util.ConcurrentModificationException== 出现了并发修改异常，快速失败机制。



### 故障原因

- 期望修改次数与真实修改次数值不同。
- 多线程添加操作下，出现了快速失败机制。
- 原因是**add**方法对于**HashSet**来说是线程不安全的。
- 并发争抢修改导致的问题，一个线程正在写，另一个线程抢夺，导致**数据不一致**问题。



### 解决方案



#### 运用集合工具类Collecitons



##### Collections.synchronizedSet方法

- **线程安全**但是**并发性下降**。

```java
public static void main(String[] args) {

    Set<String> strings = Collections.synchronizedSet( new HashSet<>());

    for (int i = 0; i < 50; i++) {
        new Thread(() -> {
            strings.add(UUID.randomUUID().toString().substring(0,8));
            System.out.println(strings);
        }, String.valueOf(i)).start();
    }
}
```



##### 运用JUC下的CopyOnWriteArraySet类（重点）

- 同样是使用了写时复制类。

```java
public static void main(String[] args) {

    CopyOnWriteArraySet<String> strings = new CopyOnWriteArraySet<>();

    for (int i = 0; i < 50; i++) {
        new Thread(() -> {
            strings.add(UUID.randomUUID().toString().substring(0,8));
            System.out.println(strings);
        }, String.valueOf(i)).start();
    }
}
```



###### CopyOnWriteArraySet类核心内容选读

- 属性	

```java
private final CopyOnWriteArrayList<E> al; // 可以看到数据结构其实是一个 CopyOnWriteArrayList 类的对象// 让我联想到了 HashSet 和 HashMap 的关系。public CopyOnWriteArraySet() {    // 调用的是 CopyOnWriteArrayList 的构造函数    al = new CopyOnWriteArrayList<E>();}
```





## HashMap线程不安全



### 案例

```java
package JUC;import java.util.*;/** * @author zhaolimin * @date 2021/11/14 * @apiNote HashMap线程不安全 */public class HashMapNotSafeDemo {    public static void main(String[] args) {        HashMap<String, String> map = new HashMap<>();        for (int i = 0; i < 50; i++) {            new Thread(() -> {                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,8));                System.out.println(map);            }, String.valueOf(i)).start();        }    }}
```



### 故障现象

- 抛出 ==java.util.ConcurrentModificationException== 出现了并发修改异常，快速失败机制。



### 故障原因

- 期望修改次数与真实修改次数值不同。
- 多线程添加操作下，出现了快速失败机制。
- 原因是**add**方法对于**HashSet**来说是线程不安全的。
- 并发争抢修改导致的问题，一个线程正在写，另一个线程抢夺，导致**数据不一致**问题。



### 解决方案



#### 运用集合工具类Collecitons

```java
public static void main(String[] args) {    Map<Object, Object> objectObjectMap = Collections.synchronizedMap(new HashMap<>());    for (int i = 0; i < 40; i++) {        new Thread(() -> {            objectObjectMap.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,8));            System.out.println(objectObjectMap);        }, String.valueOf(i)).start();    }}
```



#### 运用JUC下的ConcurrentHashMap类（重点）

- ###### 该类详解看之前的笔记。

```java
public static void main(String[] args) {    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();    for (int i = 0; i < 40; i++) {        new Thread(() -> {            map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0,8));            System.out.println(map);        }, String.valueOf(i)).start();    }}
```



## 传值问题 （重要基本功）



### 案例

- person类

```java
public class Person {    private Integer id;    private String personName;    public Person() {    }    public Person(String personName) {        this.personName = personName;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getPersonName() {        return personName;    }    public void setPersonName(String personName) {        this.personName = personName;    }}
```

- 测试类

```java
public class TestTransferValueDemo {    public void changeValue1(int age) {        age = 30;    }    public void changeValue2(Person person) {        person.setPersonName("zlm");    }    public void changeValue3(String str) {        str = "wl";    }    // main线程在栈内存启动    public static void main(String[] args) {                TestTransferValueDemo testTransferValueDemo = new TestTransferValueDemo();		        // 基本数据类型        int age = 20;        testTransferValueDemo.changeValue1(age);        System.out.println("-------- age = " + age);        Person person = new Person("xxx");        testTransferValueDemo.changeValue2(person);        System.out.println("-------- personName = " + person.getPersonName());        String str = "xxx";        testTransferValueDemo.changeValue3(str);        System.out.println("-------- str = " + str);    }}
```

- 打印结果

```java
/*	-------- age = 20    -------- personName = zlm    -------- str = xxx*/
```



### 为什么会出现这样的结果

- ==栈管运行，堆管存储==。
- **栈空间是线程私有，堆的是数据共享**。



- **age的结果**：
  - 是因为自始至终，基本数据类型都是传递的数据副本，副本改变根本影响不到原件的值，所谓的**值传递**。
- **person的结果**：
  - 传递的是引用，函数参数以及main中引用，指向的都是同一堆内存中的地址。
  - 也就是对象在堆内存中的地址，修改了那个地址上的值。
- **str的结果**：
  - **String 类型**的 **字符数组 是 final 修饰的**，说明==是一个不可更改的常量，只能新建==。
  - 对于 **changeValue3 方法中的 str**，它原本是和 **main 中的 str** 一样**指向常量池里的 “xxx”**。
  - 但是 **changeValue3 中的 str** 又被强行指向了一个叫 **“wl”** 的字符串常量，但是在**常量池里并没有这个字符串**。
  - **由于字符串是常量，不能修改只能新建。**
  - 于是常量池中会**新建一个字符串常量 “wl”** 然后 **changeValue3 中的 str** 将指向这个**新建 “wl” 字符串**。
  - 由于 ==“wl” 字符串和 “xxx” 字符串在常量池中的地址不同==，就导致了 **main 中的 str** 和 **changeValue3 中的 str** ==不是指向同一个常量池地址==。
  - 而题中我们要打印的是 **main 中的 str** 所指的堆内存常量池中的内容为 **“xxx”**，而不是 **“wl”**，
  - 所以我们打印的是 **“xxx”**。
  - 对于`String str = new String("hello world");`==运行期创建就存储在堆中==。
  - 对于 `String str = "hello world;"` ==编译期创建的放在**常量池**中==。



### 总结

- String类型特殊，需要单独看待。
- 引用类型复制的是地址。
- **对于基础类型的变量和常量**：变量和引用存储在栈中，常量存储在常量池中。



## 可重入锁（递归锁）



### 什么是可重入锁什么是可重入锁

- 指的是**同一线程的外层函数获得锁之后**，内层递归函数仍能获取该锁的代码。
- 在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
- ==线程可以进入一个它已经拥有的锁所同步着的代码块！==
- 也就是说，**已经加锁的代码块中还有有锁方法调用，那么这个调用的方法也会获取这个锁**。  
- 锁定的是对象，如果获得锁了，那么被**这个锁修饰的方法/代码块**都可以进行访问。

```java
// method01 是上锁了的，此时内部调用了 method02 方法，
// 此时虽然 method02 也是同步方法，但是调用 method01 之后，他俩共用 method01 的锁。
// 锁里套锁才算是可重入锁。
public synchronized void method01() { 
    method02();
}

public synchronized void method02() {
    
}
```



### 作用

- ==最大作用就是用来避免死锁。==
- 避免死锁说的是两个同步方法互相调用的时候，如果不可重入，会造成循环等待，造成死锁。



### ReentrantLock类可重入锁

- 与 **synchronized** 关键字一样他俩**默认都是非公平的可重入锁**！



#### 构造方法

```java
public ReentrantLock() {
    sync = new NonfairSync(); // 默认创建一个非公平锁
}
```

```java
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync(); // 创建一个公平锁或非公平锁
}
```



#### 测试案例

```java
package JUC.lock;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author zhaolimin
 * @date 2021/11/14
 * @apiNote ReenterLockDemo 测试类
 */

class Test01 {

    Lock lock = new ReentrantLock();

    public void get() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 调用了 get() 方法");
            System.out.println("此时锁为： " + this);
            this.getIn();
        } finally {
            lock.unlock();
        }
    }

    public void getIn() {
        System.out.println(Thread.currentThread().getName() + "\t 调用了getIn() 方法");
        System.out.println("此时锁为： " + this);
    }
}

public class ReenterLockDemo {

    public static void main(String[] args) {
        Test01 test01 = new Test01();
        for (int i = 0; i < 2; i++) {
            new Thread(() -> {
                try {
                    test01.get();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }, String.valueOf(i)).start();
        }

    }
}
```

```java
/*
    0	 调用了 get() 方法
    此时锁为： JUC.lock.Test01@2322e888
    0	 调用了getIn() 方法
    此时锁为： JUC.lock.Test01@2322e888
    1	 调用了 get() 方法
    此时锁为： JUC.lock.Test01@2322e888
    1	 调用了getIn() 方法
    此时锁为： JUC.lock.Test01@2322e888
*/
```



### Synchronized 关键字可重入锁

#### 测试案例

```java
package JUC.lock;

/**
 * @author zhaolimin
 * @date 2021/11/14
 * @apiNote Synchronized 关键字可重入锁测试
 */

class Tickets {

    public void book() throws Exception{
        synchronized (this) {
            System.out.println(Thread.currentThread().getName() + "\t 调用了 book() 方法");
            System.out.println("此时锁为： " + this);
            this.cancel();
        }
    }

    public void cancel() throws Exception{
        System.out.println(Thread.currentThread().getName() + "\t 调用了 cancel() 方法");
        int index = 0;
        while (true) {
            System.out.println("此时锁为： " + this);
            if (index == 5) {
                break;
            }
            index ++ ;
        }
    }
}
public class SynchronizedDemo {

    public static void main(String[] args) {
        Tickets tickets = new Tickets();
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    tickets.book();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }, String.valueOf(i)).start();
        }
    }
}
```

```java
/*
    0	 调用了 book() 方法
    此时锁为： JUC.lock.Tickets@74c00d
    0	 调用了 cancel() 方法
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    1	 调用了 book() 方法
    此时锁为： JUC.lock.Tickets@74c00d
    1	 调用了 cancel() 方法
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
    此时锁为： JUC.lock.Tickets@74c00d
*/
```





## 公平锁和非公平锁



### 是什么

- **公平锁**：
  - 多个线程**按照申请锁的顺序来进行锁的获取，先来后到**。
- **非公平锁**：
  - 多个线程**获取锁的顺序不按照申请锁的顺序**，会出现后申请的线程比先申请的线程先获取锁的情况。
  - 高并发情况下，**有可能会造成优先级反转或者饥饿现象**。



### 两者区别

- 拿**ReentrantLock**来说。
- 并发包中的 **ReentrantLock** 可重入锁可以创建公平锁或非公平锁，默认是非公平锁。

```java
public class LockDemo01 {

    volatile int n = 0;

    public void add() {
        n++;
    }

    public static void main(String[] args) {

        // 非公平锁
        Lock lock1 = new ReentrantLock();

        // 公平锁
        Lock lock2 = new ReentrantLock(true);

    }
}
```



- **公平锁在JAVA中来说**：

  - 在并发环境中，每个线程在获取锁的时候会**先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，按照FIFO的规则从队列中排队等锁**。
  - **synchronized** **也是一种公平锁**。

  

- **非公平锁在JAVA中来说**：

  - 上来线程就可以直接尝试抢占锁，如果成功，直接获取锁，如果不成功，那就按照类似公平锁的方式来获取锁。
  - 优点在于它的**吞吐量大**。

  ​                                        

## 自旋锁



### 是什么

- 是指尝试获取锁的线程不会**立即阻塞**，而是==采用循环的方式去尝试获取锁==。
- **获取锁的线程一直处于活跃状态**，但是并**没有执行任何有效的任务**，使用这种锁会造成 **busy-waiting**。
- 优点是**减少线程上下文切换的消耗**。
- 缺点是**循环会消耗CPU资源**。
- 可以参考 **Unsafe.getAndAddInt** 方法。



### 测试案例

- 主要采用了 **CAS 操作**来实现。

```java
package JUC.lock;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicReference;/** * @author zhaolimin * @date 2021/11/14 * @apiNote 自旋锁测试 */public class SpinLockDemo {    // 原子引用线程    AtomicReference<Thread> threadAtomicReference = new AtomicReference<>();    public void myLock() {        Thread thread = Thread.currentThread();        // 如果期望值是null，主内存中也是null，那主内存中threadAtomicReference的值就为thread        System.out.println(thread.getName()+ "线程\t 获取锁中。。。");        while (!threadAtomicReference.compareAndSet(null,thread)) {                    }        System.out.println(thread.getName()+ "线程\t 获取锁成功，占用中。。。");    }    public void myUnLock() {        Thread thread = Thread.currentThread();        threadAtomicReference.compareAndSet(thread,null);        System.out.println(thread.getName()+ "线程\t 解锁成功。");    }    public static void main(String[] args) {        SpinLockDemo spinLockDemo = new SpinLockDemo();        new Thread(() -> {            spinLockDemo.myLock();            try {                TimeUnit.SECONDS.sleep(8);            } catch (InterruptedException e) {                e.printStackTrace();            }            spinLockDemo.myUnLock();        }, "t1").start();        try {            TimeUnit.SECONDS.sleep(3);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -> {            spinLockDemo.myLock();            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            spinLockDemo.myUnLock();        }, "t2").start();    }}
```

```java
/*  	占用 8 秒 --------------------------    t1线程	 获取锁中。。。    t1线程	 获取锁成功，占用中。。。      3 秒后 t2 线程尝试获取锁 --------------------------    t2线程	 获取锁中。。。        8 秒后 t1 线程释放锁 --------------------------    t1线程	 解锁成功。        t2线程	 获取锁成功，占用中。。。    t2线程	 解锁成功。	*/
```



## 读写锁

- **拆开来，就是独占锁（写锁），共享锁（读锁）**。



### 独占锁

- **指该锁一次只能被一个线程持有**。
- 对 **ReentrantLock**类、**synchronized** 关键字来说都是独占锁。



### 共享锁

- **指该锁可可以被多个线程持有**。
- 对 **ReentrantReadWriteLocl**类来说，读锁为共享锁，写锁为独占锁。
- **读锁的共享锁可以保证并发环境下线程读的效率**。
- 写写、读写、写读的过程是互斥的。



### ReentrantReadWriteLock类

#### 两个重要方法

```java
// 获取写锁，独占锁形式public ReentrantReadWriteLock.WriteLock writeLock() {     return writerLock; }// 获取读锁，共享锁形式public ReentrantReadWriteLock.ReadLock  readLock()  {     return readerLock; }
```



### 案例

- **写操作  =  原子 + 独占**
- **读读能共存，读写、写写不能共存**。

```java
package JUC.lock;import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * @author zhaolimin * @date 2021/11/14 * @apiNote 读写锁测试类。 */class MyCache {    private volatile Map<String,Object> map= new HashMap<>(); // 满足可见性、禁止指令重排    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();    public void put(String key, Object value) {        // 上独占锁写锁。        readWriteLock.writeLock().lock();        try {            System.out.println(Thread.currentThread().getName() + "\t 正在写入：" + key);            // 暂停0.3秒。            try {                TimeUnit.MICROSECONDS.sleep(300);            } catch (InterruptedException e) {                e.printStackTrace();            }            map.put(key, value);            System.out.println(Thread.currentThread().getName() + "\t 写入完成：" + key);        } finally {            readWriteLock.writeLock().unlock();        }    }    public void get(String key) {        // 上共享读锁        readWriteLock.readLock().lock();        try {            System.out.println(Thread.currentThread().getName() + "\t 正在读取：" + key);            // 暂停0.3秒。            try {                TimeUnit.MICROSECONDS.sleep(300);            } catch (InterruptedException e) {                e.printStackTrace();            }            Object result = map.get(key);            System.out.println(Thread.currentThread().getName() + "\t 读取完成：" + result );        } finally {            readWriteLock.readLock().unlock();        }    }    public void clearMap() {        map.clear();    }}public class ReadWriteLockDemo {    public static void main(String[] args) {        MyCache myCache = new MyCache();        for (int i = 1; i <= 5; i++) {            // 匿名内部类使用外部的局部变量，这个局部变量必须用final修饰来保证数据的一致性。            final int tempInt = i;            new Thread(() -> {                myCache.put(tempInt+"", tempInt+"");            }, String.valueOf(i)).start();        }        for (int i = 1; i <= 5; i++) {            // 匿名内部类使用外部的局部变量，这个局部变量必须用final修饰来保证数据的一致性。            final int tempInt = i;            new Thread(() -> {                myCache.get(tempInt+"");            }, String.valueOf(i)).start();        }    }}
```

```java
/*    2	 正在写入：2    2	 写入完成：2    1	 正在写入：1    1	 写入完成：1    3	 正在写入：3    3	 写入完成：3    4	 正在写入：4    4	 写入完成：4    5	 正在写入：5    5	 写入完成：5    1	 正在读取：1    2	 正在读取：2    3	 正在读取：3    4	 正在读取：4    5	 正在读取：5    1	 读取完成：1    5	 读取完成：5    3	 读取完成：3    2	 读取完成：2    4	 读取完成：4*/
```



## 工具类

### CountDownLactch



#### 简述

- 允许一个或多个线程等待，直到在其他线程中执行的一组操作完成，同步辅助。 
- **CountDownLatch **类用给定的**计数**初始化。
- **await** 方法阻塞，直到由于 **countDown()** 方法的**调用**而导致当前计数达到零后所有等待线程被释放，并且任何后续的 **await** 调用立即返回。  
- 这是一个一次性的计数操作，因为计数无法重置。 
- 如果需要重置计数的版本，请考虑使用 **CyclicBarrier **类。



#### 构造函数

```java
/*
    参数 
    count 减的次数 countDown() 必须调用之前线程可以通过 await() 
    异常 
    IllegalArgumentException  如果此时 count 为负数。
*/
public CountDownLatch(int count) {
    if (count < 0) throw new IllegalArgumentException("count < 0");
    this.sync = new Sync(count);
}
```



#### await方法

```java
/*
    导致当前线程等到锁存器计数到零，除非线程是interrupted 。 
    如果当前计数为零，则此方法立即返回。 

    如果当前计数大于零，则当前线程将被禁用以进行线程调度，并处于休眠状态，直至发生两件事情之一： 

    由于countDown()方法的调用，计数达到零; 要么 
    一些其他线程interrupts当前线程。 
    如果当前线程： 

    在进入该方法时设置了中断状态; 要么 
    是interrupted等待， 
    然后InterruptedException被关上，当前线程的中断状态被清除。 
*/
public void await() throws InterruptedException {
    // 获取可中断的共享
    sync.acquireSharedInterruptibly(1); 
}
```

```java
public final void acquireSharedInterruptibly(int arg)
    throws InterruptedException {
    // 如果当前await的线程被中断了，那就抛出异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 尝试获取共享
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}
```

```java
private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```



#### 案例

```java
package JUC.api;

import JUC.myenum.CountryEnum;

import java.util.concurrent.CountDownLatch;

/**
 * @author zhaolimin
 * @date 2021/11/15
 * @apiNote CountDownLatch倒计时的使用
 */
public class CountDownLatchDemo {

    private int count = 6;

    public int getCount() {
        return this.count;
    }

    public static void main(String[] args) throws Exception{

        fight();

    }

    public static void fight() throws Exception{
        CountDownLatch countDownLatch = new CountDownLatch(new CountDownLatchDemo().getCount());

        for (int i = 1; i < 7; i++) {

            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t被秦所灭。。。");
                countDownLatch.countDown();
            }, CountryEnum.foreachCountryEnum(i).getResultMessage()).start();
        }

        countDownLatch.await();
        System.out.println("秦朝建立");
    }
}

```

```java
package JUC.myenum;

/**
 * @author zhaolimin
 * @date 2021/11/15
 * @apiNote 国家枚举
 */
public enum CountryEnum {

    ONE(1,"齐"),
    TWO(2,"楚"),
    THREE(3,"燕"),
    FOUR(4,"韩"),
    FIVE(5,"赵"),
    SIX(6,"魏");

    private Integer resultCode;
    private String resultMessage;

    CountryEnum(Integer resultCode, String resultMessage) {
        this.resultCode = resultCode;
        this.resultMessage = resultMessage;
    }

    public Integer getResultCode() {
        return resultCode;
    }

    public String getResultMessage() {
        return resultMessage;
    }

    // 找到对应的枚举
    public static CountryEnum foreachCountryEnum(int index) {

        // 枚举天生就带着自己的一种遍历方法
        CountryEnum[] values = CountryEnum.values();
        for (CountryEnum value:
             values) {
            // 找到对应枚举就返回
            if (index == value.getResultCode()) {
                return value;
            }
        }
        // 找不到对应枚举就返回null
        return null;
    }
}
```

```java
/*
    齐	被秦所灭。。。
    赵	被秦所灭。。。
    魏	被秦所灭。。。
    韩	被秦所灭。。。
    楚	被秦所灭。。。
    燕	被秦所灭。。。
    秦朝建立
*/
```





### CyclicBarrier



#### 简述

- 允许一组线程全部等待彼此达到共同屏障点的同步辅助。 
- **循环阻塞在涉及固定大小的线程方的程序中很有用**，这些线程**必须偶尔等待彼此**。
- **屏障被称为循环**  ，因为**它可以在等待的线程被释放之后重新使用**。 
- 它会在某个代码段后设置 **await** 方法，只有执行到当前 **await** 方法的代码段的线程达到一定数量才会解除阻塞状态运行别的。



#### 构造函数

- 创建一个新的 CyclicBarrier ，当给定数量的线程（线程）等待时，它将跳闸，当屏障跳闸时执行给定的屏障动作，由最后一个进入屏障的线程执行。 

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction; // 到达计数点之后要执行的动作，Runnable接口
}
```



#### await方法

```java
    public int await() throws InterruptedException, BrokenBarrierException {        try {            return dowait(false, 0L);        } catch (TimeoutException toe) {            throw new Error(toe); // cannot happen        }    }
```

```java
private int dowait(boolean timed, long nanos)    throws InterruptedException, BrokenBarrierException,TimeoutException {    // 可以看到这个还是一个可重入锁    final ReentrantLock lock = this.lock;    lock.lock();    try {        final Generation g = generation;        // 判断屏障是否被破坏        if (g.broken)            throw new BrokenBarrierException();	    // 判断当前被阻塞线程是否被中断        if (Thread.interrupted()) {            // 中断就打破屏障            breakBarrier();            throw new InterruptedException();        }        // 通过减法来进行判断        int index = --count;        // 如果此时循环等待的await的线程数够了，就放行 runnable 线程的动作        if (index == 0) {  // tripped            boolean ranAction = false;            try {                final Runnable command = barrierCommand;                 // 如果构造函数里传入了屏障结束之后要进行的动作                if (command != null)                    // 如果有的话就运行                    command.run();                ranAction = true;                nextGeneration();                return 0;            } finally {                if (!ranAction)                    breakBarrier();            }        }        // loop until tripped, broken, interrupted, or timed out        for (;;) {            try {                if (!timed)                    trip.await();                else if (nanos > 0L)                    nanos = trip.awaitNanos(nanos);            } catch (InterruptedException ie) {                if (g == generation && ! g.broken) {                    breakBarrier();                    throw ie;                } else {                    // We're about to finish waiting even if we had not                    // been interrupted, so this interrupt is deemed to                    // "belong" to subsequent execution.                    Thread.currentThread().interrupt();                }            }            if (g.broken)                throw new BrokenBarrierException();            if (g != generation)                return index;            if (timed && nanos <= 0L) {                breakBarrier();                throw new TimeoutException();            }        }    } finally {        lock.unlock();    }}
```



#### 案例

```java
package JUC.api;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * @author zhaolimin * @date 2021/11/15 * @apiNote  CyclicBarrier循环屏障使用 */public class CyclicBarrierDemo {    public static void main(String[] args) {        // 它会等待到七个线程运行结束之后最后再运行 Runnable 接口实现的方法。        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {            System.out.println("召唤神龙！");        });        for (int i = 1; i < 8; i++) {            int temp = i;            new Thread(() -> {                System.out.println(Thread.currentThread().getName() + "\t 收集到第 " + temp + "颗龙珠");                // 收集完一个龙珠就在这阻塞等待                // 等待七个龙珠也就是七个线程都运行到这里，才执行解锁。                try {                    cyclicBarrier.await();                } catch (InterruptedException e) {                    e.printStackTrace();                } catch (BrokenBarrierException e) {                    e.printStackTrace();                }            }, String.valueOf(i)).start();        }    }}
```

```java
/*    1	 收集到第 1颗龙珠    7	 收集到第 7颗龙珠    6	 收集到第 6颗龙珠    5	 收集到第 5颗龙珠    2	 收集到第 2颗龙珠    4	 收集到第 4颗龙珠    3	 收集到第 3颗龙珠    召唤神龙！*/
```



### Semaphore



#### 简述

- 一个计数信号量。 
- 在概念上，信号量**维持一组许可证**。 如果有必要，每个**acquire()阻塞**，**直到许可证可用**，然后才能使用它。 
- 每个**release()添加许可证**，**潜在地释放阻塞获取方**。  
- 但是，没有使用实际的许可证对象 **Semaphore** 只保留**可用数量的计数**，并相应地执行就可以。
- ==一般用在多个线程抢多个资源的情况。==
- 可以变相替代 **synchronized** 和 **lock**。



#### 构造函数

```java
// 不设置第二个参数默认非公平锁// 第一个是信号量数public Semaphore(int permits, boolean fair) {    sync = fair ? new FairSync(permits) : new NonfairSync(permits);}
```



#### acquire方法

```java
// 从该信号量获取许可证，阻止直到可用，或线程为 interruptedpublic void acquire() throws InterruptedException {    sync.acquireSharedInterruptibly(1);}
```

```java
public final void acquireSharedInterruptibly(int arg)    throws InterruptedException {    if (Thread.interrupted())        throw new InterruptedException();    if (tryAcquireShared(arg) < 0)        doAcquireSharedInterruptibly(arg);}
```

```java
private void doAcquireSharedInterruptibly(int arg)    throws InterruptedException {    final Node node = addWaiter(Node.SHARED);    boolean failed = true;    /*        如果没有足够的许可证可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，直到发生两件事情之一：         一些其他线程调用此信号量的一个release方法，当前线程旁边将分配许可证，并且可用许可证的数量满足此请求;        要么一些其他线程interrupts当前线程。    */    try {        for (;;) {            final Node p = node.predecessor();            if (p == head) {                int r = tryAcquireShared(arg);                if (r >= 0) {                    setHeadAndPropagate(node, r);                    p.next = null; // help GC                    failed = false;                    return;                }            }            if (shouldParkAfterFailedAcquire(p, node) &&                parkAndCheckInterrupt())                throw new InterruptedException();        }    } finally {        if (failed)            cancelAcquire(node);    }}
```



#### 案例

- 信号量控制的代码段为：
  - **semaphore.acquire() 与 semaphore.release()** 中间的那一段代码段。

```java
package JUC.api;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;/** * @author zhaolimin * @date 2021/11/15 * @apiNote 信号量测试 */public class SemaphoreDemo {    public static void main(String[] args) {        // 不设置第二个参数默认非公平锁        // 模拟十个车位。        Semaphore semaphore = new Semaphore(5, false);        // 模拟二十辆车来        for (int i = 1; i <= 10; i++) {            new Thread(() -> {                try {                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + "车\t抢到车位。。。");                    TimeUnit.SECONDS.sleep(3); // 暂停一会线程，假装每个车在车位上停三秒                    System.out.println(Thread.currentThread().getName() + "车\t停车三秒后离开车位！");                } catch (InterruptedException e) {                    e.printStackTrace();                } finally {                    semaphore.release();                }            }, String.valueOf(i)).start();        }    }}
```

```java
/*
    1车	抢到车位。。。
    5车	抢到车位。。。
    4车	抢到车位。。。
    2车	抢到车位。。。
    3车	抢到车位。。。
    5车	停车三秒后离开车位！
    3车	停车三秒后离开车位！
    2车	停车三秒后离开车位！
    6车	抢到车位。。。
    4车	停车三秒后离开车位！
    8车	抢到车位。。。
    9车	抢到车位。。。
    7车	抢到车位。。。
    1车	停车三秒后离开车位！
    10车	抢到车位。。。
    6车	停车三秒后离开车位！
    9车	停车三秒后离开车位！
    8车	停车三秒后离开车位！
    10车	停车三秒后离开车位！
    7车	停车三秒后离开车位！
*/
```



## 阻塞队列



### 什么是阻塞队列

- 顾名思义是一个队列。
- **当阻塞队列是空的时候**，**线程**从队列中**获取**元素的操作将会被阻塞。
- **当阻塞队列是满的时候**，**线程**往队列里**添加**元素的操作将会被阻塞。
- 很像**生产者消费者**模型。

| ![image-20211115150142032](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211115150142032.png) |
| :----------------------------------------------------------: |
|  **线程一往阻塞队列中添加元素，线程二往阻塞队列中移除元素**  |



- **阻塞队列有没有好的一面**？
  - 在 **JUC** 发布之前，多线程环境下，我们每个开发者都得自己去控制什么时候阻塞线程什么时候唤醒线程，尤其是要兼顾效率和线程安全，这样做会给程序带来很大的复杂度，容易出错，不好测试。
  - **我们不用关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切都被阻塞队列包了。**
  - 在多线程领域：
    - 所谓阻塞，就是**某些情况下会挂起线程，一旦条件满足，被挂起的线程又会被自动唤醒。**
- 不得不阻塞的话如何管理？



### ArrayBlockingQueue

#### 简述

- 它是一个**基于数组结构**的有界限的阻塞队列。
- 此队列按照 **FIFO（先进先出）**原则对元素进行排序。



### LinkedBlockingQueue

#### 简述

- 一个基于**链表结构**的阻塞队列，此队列按照 **FIFO（先进先出）**排序元素。
- 有界的，默认大小为 **int** 类型的最大值。
- 吞吐量通常要高于 **ArrayBlockingQueue** 。



### SynchronousQueue

#### 简述

- 一个**不存储元素**的阻塞队列。
- 每个**插入操作必须等待另一个线程调用移除操作**。
- 每个 **put()** 对应一个 **take()**。
- 否则插入操作一直处于阻塞状态，吞吐量通常高于 **LinkedBlockingQueue**。
- 慎用。



#### 示例

```java
package JUC.block;import java.util.concurrent.BlockingQueue;import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/** * @author zhaolimin * @date 2021/11/16 * @apiNote */public class SynchronousQueueDemo {    public static void main(String[] args) {        BlockingQueue<String> strings = new SynchronousQueue<>();            new Thread(() -> {                try {                    // 不断尝试往里添加                    System.out.println(Thread.currentThread().getName() + "线程\t 添加 1 ");                    strings.put("1");                    System.out.println(Thread.currentThread().getName() + "线程\t 添加 2 ");                    strings.put("2");                    System.out.println(Thread.currentThread().getName() + "线程\t 添加 3 ");                    strings.put("3");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }, "A").start();            new Thread(() -> {                try {                    // 过五秒钟取一次，造成上面添加的阻塞                    TimeUnit.SECONDS.sleep(5);                    System.out.println(Thread.currentThread().getName() + "线程\t 取出 1 ");                    strings.take();                    TimeUnit.SECONDS.sleep(5);                    System.out.println(Thread.currentThread().getName() + "线程\t 取出 2 ");                    strings.take();                    TimeUnit.SECONDS.sleep(5);                    System.out.println(Thread.currentThread().getName() + "线程\t 取出 3 ");                    strings.take();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }, "B").start();    }}
```

```java
/*    A线程	 添加 1     B线程	 取出 1     A线程	 添加 2     B线程	 取出 2     A线程	 添加 3     B线程	 取出 3 */
```



### 其它阻塞队列

#### PriorityBlockingQueue

- 支持优先级排序的**无界阻塞队列**。



#### DelayQueue

- **使用优先级队列实现的延迟无界阻塞队列**。



#### LinkedTransferQueue

- 由链表构成的**无界阻塞队列**。



#### LinkedBlockingDeque

- 由链表构成的**双向阻塞队列**。



## BlockingQueue的核心方法

| 方法类型 | 抛出异常  |  特殊值  |  阻塞  |        超时        |
| :------: | :-------: | :------: | :----: | :----------------: |
| **插入** |  add(e)   | offer(e) | put(e) | offer(e,time,unit) |
| **移除** | remove()  |  poll()  | take() |  poll(time,unit)   |
| **检查** | element() |  peek()  | 不可用 |       不可用       |

| 抛出异常     | 当阻塞队列满了的时候，再往队列里 add数据 会抛出IllegalStateException：Queue full异常，当阻塞队列空的时候，再往队列里 remove 数据会抛出NoSuchElementException异常。 |
| ------------ | ------------------------------------------------------------ |
| **特殊值**   | 插入方法，成功返回**true**失败返回**false**；移除方法，成功**返回出队元素**，**队列里面没有就返回null**。 |
| **一直阻塞** | 当阻塞队列满的时候，**生产者**线程**继续往队列里 put 元素**的话，**队列会一直阻塞生产线程直到 put 数据或者响应中断退出**。当**阻塞队列空**的时候，**消费者**线程**试图从队列里 take 元素的话，队列会一直阻塞消费者线程直到队列可用。** |
| 超时         | 过时不候                                                     |



### 抛出异常组测试

- 测试了 **BlockingQueue** 中**会抛出异常**的三个方法的使用。

```java
package JUC.api;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * @author zhaolimin * @date 2021/11/15 * @apiNote 阻塞队列demo */public class BlockingQueueDemo {    public static void main(String[] args) throws Exception {        System.out.println("--------------------初始容量为三插入三个数据-----------------------");        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); // 没有无参构造，队列初始化容量为三        System.out.println(blockingQueue.add("a"));        System.out.println(blockingQueue.add("b"));        System.out.println(blockingQueue.add("c"));        System.out.println("----------------------容量刚好到三---------------------");        System.out.println();        // 初始容量为三，三过了之后就会抛异常 Queue full        try {            System.out.println("----------------------添加第四个数据越界抛出异常---------------------");            System.out.println(blockingQueue.add("d"));            System.out.println();        } catch (IllegalStateException e) {            e.printStackTrace();        }        System.out.println("检查一下当前元素空不空，不空的话队首元素是：" + blockingQueue.element());        System.out.println();        System.out.println("--------------------移除三个数据-----------------------");        System.out.println(blockingQueue.remove());        System.out.println(blockingQueue.remove());        System.out.println(blockingQueue.remove());        System.out.println();        try {            System.out.println("--------------------移除第四个数据发现抛出异常-----------------------");            // 队列中没有元素了再移除会抛异常 NoSuchElementException            System.out.println(blockingQueue.remove());            System.out.println();        } catch (IllegalStateException e) {            e.printStackTrace();        }    }}
```

```java
/*	    --------------------初始容量为三插入三个数据-----------------------    true    true    true    ----------------------容量刚好到三---------------------    ----------------------添加第四个数据越界抛出异常---------------------    检查一下当前元素空不空，不空的话队首元素是：a    --------------------移除三个数据-----------------------    a    b    c    --------------------移除第四个数据发现抛出异常-----------------------    java.lang.IllegalStateException: Queue full        at java.util.AbstractQueue.add(AbstractQueue.java:98)        at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)        at JUC.api.BlockingQueueDemo.main(BlockingQueueDemo.java:25)    Exception in thread "main" java.util.NoSuchElementException        at java.util.AbstractQueue.remove(AbstractQueue.java:117)        at JUC.api.BlockingQueueDemo.main(BlockingQueueDemo.java:42)*/
```



### 返回布尔值组（特殊值组）测试

- 测试了 **BlockingQueue** 中会**返回特殊值**的三个方法的使用。

```java
package JUC.block;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * @author zhaolimin * @date 2021/11/15 * @apiNote 阻塞队列demo */public class BlockingQueueDemo {    public static void main(String[] args) throws Exception {        System.out.println("--------------------初始容量为三插入三个数据-----------------------");        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); // 没有无参构造，队列初始化容量为三        System.out.println(blockingQueue.offer("a"));        System.out.println(blockingQueue.offer("b"));        System.out.println(blockingQueue.offer("c"));        System.out.println("----------------------容量刚好到三---------------------");                System.out.println("尝试插入第四个值，返回插入结果：" + blockingQueue.offer("d")); // 我们看到boolean值组就是不抛异常        System.out.println("检查一下当前元素空不空，不空的话队首元素是：" + blockingQueue.peek());        System.out.println();                System.out.println("----------------------取元素---------------------");        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll());        System.out.println(blockingQueue.poll()); // 队列没有值了就返回null    }}
```

```java
/*    --------------------初始容量为三插入三个数据-----------------------    true    true    true    ----------------------容量刚好到三---------------------    尝试插入第四个值，返回插入结果：false    检查一下当前元素空不空，不空的话队首元素是：a    ----------------------取元素---------------------    a    b    c    null*/
```



### 阻塞组测试

- 测试了 **BlockingQueue** 中会**阻塞值**的两个方法的使用。
- 由于这个方法在多线程下可能更直观，于是就换成了多线程的写法。

```java
package JUC.block;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;/** * @author zhaolimin * @date 2021/11/15 * @apiNote 阻塞队列demo */public class BlockingQueueDemo {    public static void main(String[] args) throws Exception {        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); // 没有无参构造，队列初始化容量为三        for (int i = 1; i <= 5; i++) {            new Thread(() -> {                try {                    System.out.println(Thread.currentThread().getName() + "\t 尝试放入数据。。。");                    blockingQueue.put("a");                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + "\t 放入数据成功！");            }, String.valueOf(i)).start();        }        for (int i = 1; i <= 5; i++) {            new Thread(() -> {                try {                    System.out.println(Thread.currentThread().getName() + "\t 尝试取出数据。。。");                    blockingQueue.take();                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + "\t 取出数据成功！");            }, String.valueOf(i)).start();        }    }}
```

```java
/*    1	 尝试放入数据。。。    5	 尝试放入数据。。。    4	 尝试放入数据。。。    3	 尝试放入数据。。。    2	 尝试放入数据。。。    4	 放入数据成功！    5	 放入数据成功！    1	 放入数据成功！    1	 尝试取出数据。。。    3	 尝试取出数据。。。    2	 尝试取出数据。。。    3	 放入数据成功！    1	 取出数据成功！    3	 取出数据成功！    5	 尝试取出数据。。。    2	 放入数据成功！    4	 尝试取出数据。。。    4	 取出数据成功！    2	 取出数据成功！    5	 取出数据成功！*/
```

- **放入成功**的提示语句**不可能有三个以上同时打印出来**。
- **取出成功**的提示语句同样也**不可能有三个以上同时又打印出来**。
- 每个线程都打印了**四条不同的提示语句**，与**预期线程安全期望**结果一致。



### 超时组测试

- 每个线程都打印了**两条不同的提示语句**，与**预期线程安全期望**结果一致。

```java
package JUC.block;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.TimeUnit;/** * @author zhaolimin * @date 2021/11/15 * @apiNote 阻塞队列demo */public class BlockingQueueDemo {    public static void main(String[] args) throws Exception {        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3); // 没有无参构造，队列初始化容量为三        for (int i = 1; i <= 5; i++) {            new Thread(() -> {                try {                    System.out.println(Thread.currentThread().getName() + "\t 放入数据成功！"                                        + blockingQueue.offer("a", 5, TimeUnit.MICROSECONDS));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }, String.valueOf(i)).start();        }        for (int i = 1; i <= 5; i++) {            new Thread(() -> {                try {                    System.out.println(Thread.currentThread().getName() + "\t 取出数据成功！"                                        + blockingQueue.poll(10, TimeUnit.MICROSECONDS));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }, String.valueOf(i)).start();        }    }}
```

```java
/*    1	 放入数据成功！true    2	 取出数据成功！a    2	 放入数据成功！true    5	 放入数据成功！true    3	 放入数据成功！true    5	 取出数据成功！null  // 走到这一步我们可以看到这个线程等不了了，直接超时走人了，没取到数据。    4	 取出数据成功！a    3	 取出数据成功！a    1	 取出数据成功！a    4	 放入数据成功！true*/
```







## 生产者消费者模型


- 一个经典的同步模型。
- 在**Java**中要制作这个模型，**得满足以下几个条件**： 
  - 高内聚低耦合前提下，线程操纵资源类。
  - 判断、干活、唤醒通知。
  - 严防多线程并发状态下的虚假唤醒。



- 传统的：sync、wait、notify
- JUC变种：lock、await、signal




- 以上这俩种都不是我们的重点。
- 下面还是来实现一下。



### 传统JUC锁版


#### 示例


- 双线程情况，大于双线程就得加多个 **condition**



```java
class Data {    private int number = 0; // 资源    private Lock lock = new ReentrantLock(); // 可重入锁    private Condition condition = lock.newCondition();    public void increment() throws Exception{        lock.lock();        try {            // 判断，防止虚假唤醒用 while 不是 if            while (number != 0) {                // 等待，不能生产                condition.await();            }            // 干活            number++;            System.out.println(Thread.currentThread().getName() + "线程\t" + this.number);            // 通知唤醒            condition.signalAll();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void decrement() throws Exception{        lock.lock();        try {            // 判断，防止虚假唤醒用 while 不是 if            while (number == 0) {                // 等待，不能消费                condition.await();            }            // 消费            number--;            System.out.println(Thread.currentThread().getName() + "线程\t" + this.number);            // 通知唤醒            condition.signalAll();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }}
```


```java
public class ProducerAndConsumerTraditionalDemo {    public static void main(String[] args) {        Data data = new Data();        // 要求写一个初始变量为0，两个线程交替操作，一个加一，一个减一，进行五轮，五轮后的结果得是0        new Thread(() -> {            for (int i = 0; i < 5; i++) {                try {                    data.increment();                } catch (Exception e) {                    e.printStackTrace();                }            }        }, "A").start();        new Thread(() -> {            for (int i = 0; i < 5; i++) {                try {                    data.decrement();                } catch (Exception e) {                    e.printStackTrace();                }            }        }, "B").start();    }}
```


```java
/*    A线程	1    B线程	0    A线程	1    B线程	0    A线程	1    B线程	0    A线程	1    B线程	0    A线程	1    B线程	0*/
```


#### 分析


- 我们一定要记住用**while循环**来判断多线程情况下的**线程阻塞**。
- 这是线程 **一对一 **的生产者消费者模型，试想如果此时是**多个生产者对多个消费者**，还能保证 **number **的数据一致性吗？不能的话怎么解决呢？





### 阻塞队列版 （重要）


- volatile/CAS/AtomicInteger/BlockQueue/原子引用/线程交互组合使用！



#### 示例一

- **线程一对一的模式，对上面的解答。**



```java
class Source {    // 默认开启进行生产和消费    private volatile boolean FLAG = true; // 禁止重排以及保证可见性    // 资源    private AtomicInteger atomicInteger = new AtomicInteger();    // 阻塞队列    BlockingQueue<String> blockingQueue = null;    // 多态阻塞队列    public Source(BlockingQueue<String> blockingQueue) {        this.blockingQueue = blockingQueue;        // 反射查看当前接口被什么类实现        System.out.println(blockingQueue.getClass().getName());    }    public void producer() throws Exception{        String data = null;        while (this.FLAG) {            data = atomicInteger.incrementAndGet() + ""; // 相当于++i            // 两秒钟存一个            if (blockingQueue.offer(data, 2L, TimeUnit.SECONDS)){                System.out.println(Thread.currentThread().getName() + "线程\t 插入队列插入" + data + "成功！");            } else {                System.out.println(Thread.currentThread().getName() + "线程\t 插入队列插入" + data + "失败！");            }            TimeUnit.SECONDS.sleep(1);        }        System.out.println(Thread.currentThread().getName() + "线程\t 被叫停！此时FLAG = false，生产者生产结束。");    }    public void consumer() throws Exception{        String result = null;        while (this.FLAG) {            result = blockingQueue.poll(2L, TimeUnit.SECONDS);            if (result == null || result.equalsIgnoreCase("")) {                this.FLAG = false;                System.out.println(Thread.currentThread().getName() + "超过两秒没有消费成功，停止消费！");                return;            }            System.out.println(Thread.currentThread().getName() + "线程\t 消费队列消费" + result + "成功！");        }    }    public void stop() {        this.FLAG = false;    }}
```


```java
public class ProAndConsBlockingQueueDemo {    public static void main(String[] args) {        Source source = new Source(new ArrayBlockingQueue<>(2));        new Thread(() -> {            System.out.println(Thread.currentThread().getName() + "线程\t 启动生产！");            try {                source.producer();            } catch (Exception e) {                e.printStackTrace();            }        }, "producer").start();        new Thread(() -> {            System.out.println(Thread.currentThread().getName() + "线程\t 启动消费！");            try {                source.consumer();            } catch (Exception e) {                e.printStackTrace();            }        }, "consumer").start();        try {            TimeUnit.SECONDS.sleep(20);        } catch (InterruptedException e) {            e.printStackTrace();        }        source.stop();    }}
```


```java
/*    producer线程	 启动生产！    consumer线程	 启动消费！    producer线程	 插入队列插入1成功！    consumer线程	 消费队列消费1成功！	...	    producer线程	 插入队列插入20成功！    consumer线程	 消费队列消费20成功！    producer线程	 被叫停！此时FLAG = false，生产者生产结束。    consumer超过两秒没有消费成功，停止消费！*/
```


##### 示例分析


-  **运行过程中，可能会出现先消费，再生产的情况！** 
   - 为什么会出现呢？因为我们**只是使用了阻塞队列来完成某个资源的生产和消费**。
   - **并没有使生产和消费的线程用锁同步**，所以**打印语句是可能出现CPU资源抢夺而打印顺序出错**。
   - 但是虽然打印会出错，但是先生产和后消费的过程已经进行过了！
   - 综上程序运行过程没有出错，但是打印语句可能排序错误，因为线程与线程之间未同步！
-  **为什么要有一个叫停操作呢？** 
   -  因为我们在使用**超时组的阻塞队列方法**的过程中，可能会发生**线程与线程之间的和谐生产与消费**。 
   -  如果我们**不在**主线程中的某一时刻中断，那么生产和消费可能就会一直进行下去。 



#### 示例二

- **多个消费者对多个生产者。**
- **头都给我想通了才设计出来的**。

```java
/** * @author zhaolimin * @date 2021/11/16 * @apiNote 生产者消费者模型阻塞队列实现 */class Source {    // 默认的消费者线程数。    private volatile int flag;    // 资源    private AtomicInteger atomicInteger = new AtomicInteger();    // 阻塞队列    BlockingQueue<String> blockingQueue = null;    // 对阻塞队列的多态阻塞队列    public Source(int flag, BlockingQueue<String> blockingQueue) {        this.flag = flag;        this.blockingQueue = blockingQueue;        // 反射查看当前接口被什么类实现        System.out.println(blockingQueue.getClass().getName());    }    public void producer() throws Exception{        String data = null;        while (this.flag > 0) {            data = atomicInteger.incrementAndGet() + ""; // 相当于++i            // 两秒钟存一个            if (blockingQueue.offer(data, 2L, TimeUnit.SECONDS)){                System.out.println(Thread.currentThread().getName() + "线程\t 插入队列插入" + data + "成功！");            } else {                System.out.println(Thread.currentThread().getName() + "线程\t 插入队列插入" + data + "失败！阻塞队列满了！");            }            // 存完之后等待两秒钟            TimeUnit.SECONDS.sleep(2);        }        System.out.println(Thread.currentThread().getName() + "线程\t 当前没有消费者了！停止生产！");    }    public void consumer() throws Exception{        String result = null;        while (this.flag > 0) {            result = blockingQueue.poll(2L, TimeUnit.SECONDS);            if (result == null || result.equalsIgnoreCase("")) {                this.flag--;                System.out.println(Thread.currentThread().getName() + "线程\t 超过四秒没有消费成功，销毁该线程，消费线程数减一！");                return;            }            System.out.println(Thread.currentThread().getName() + "线程\t 消费队列消费" + result + "成功！");        }    }    public void stop() {        this.flag = 0;    }}
```

```java
public class ProAndConsBlockingQueueDemo {    public static void main(String[] args) {        int count = 3;        Source source = new Source(count, new ArrayBlockingQueue<>(2));        for (int i = 1; i <= count; i++) {            final int temp = i;            new Thread(() -> {                System.out.println(Thread.currentThread().getName() + "线程\t 启动生产！");                try {                    source.producer();                } catch (Exception e) {                    e.printStackTrace();                }            }, "producer" + temp).start();        }        for (int i = 1; i <= count; i++) {            final int temp = i;            new Thread(() -> {                System.out.println(Thread.currentThread().getName() + "线程\t 启动消费！");                try {                    source.consumer();                } catch (Exception e) {                    e.printStackTrace();                }            }, "consumer" + i).start();        }        try {            TimeUnit.SECONDS.sleep(20);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("主线程叫停！");        source.stop();    }}
```

```java
/*    producer1线程	 启动生产！    producer3线程	 启动生产！    producer2线程	 启动生产！    consumer1线程	 启动消费！    consumer2线程	 启动消费！    consumer3线程	 启动消费！    producer1线程	 插入队列插入1成功！    producer3线程	 插入队列插入2成功！    consumer1线程	 消费队列消费1成功！    consumer2线程	 消费队列消费3成功！    consumer3线程	 消费队列消费2成功！    producer2线程	 插入队列插入3成功！    consumer1线程	 消费队列消费4成功！    producer1线程	 插入队列插入6成功！    producer3线程	 插入队列插入4成功！    consumer2线程	 消费队列消费5成功！    consumer3线程	 超过四秒没有消费成功，销毁该线程，消费线程数减一！    producer2线程	 插入队列插入5成功！    consumer1线程	 消费队列消费6成功！    producer3线程	 插入队列插入7成功！    producer2线程	 插入队列插入8成功！    consumer2线程	 消费队列消费7成功！    consumer2线程	 消费队列消费9成功！    consumer1线程	 消费队列消费8成功！    producer1线程	 插入队列插入9成功！    producer2线程	 插入队列插入10成功！    producer1线程	 插入队列插入12成功！    producer3线程	 插入队列插入11成功！    consumer2线程	 消费队列消费10成功！    consumer2线程	 消费队列消费12成功！    consumer1线程	 消费队列消费11成功！    consumer2线程	 超过四秒没有消费成功，销毁该线程，消费线程数减一！    producer2线程	 插入队列插入13成功！    producer3线程	 插入队列插入15成功！    consumer1线程	 超过四秒没有消费成功，销毁该线程，消费线程数减一！    producer2线程	 当前没有消费者了！停止生产！    producer3线程	 当前没有消费者了！停止生产！    producer1线程	 插入队列插入14失败！阻塞队列满了！    producer1线程	 当前没有消费者了！停止生产！    主线程叫停！*/
```

##### 示例分析

- 我们可以看到只要此时的**某个消费线程被销毁了**，可以**立即被感知**到，并且**flag--操作不会被指令重排**，运用了 **volatile** 关键字的作用。
- 同样会出现，**先消费再生产的情况**，具体原因见示例一的分析部分。



## **synchronized** 和 **lock** 的区别？（重点）


### 原始构成


-  **synchronized** 是关键字，它是属于**JVM**层面的。 
   - **monitorenter**：底层是通过 **monitor** 对象来完成，其实 **wait/notify 等方法**也**依赖 monitor** 对象。
   - 所以只有在**synchronized**关键字**同步块**或者**方法**中才能调用  **wait/notify 等方法**。
   - **monitorexit**。
   - **JVM指令**：

```java
Code:       0: new           #2                  // class java/lang/Object       3: dup       4: invokespecial #1                  // Method java/lang/Object."<init>":()V       7: dup       8: astore_1       // synchronized 关键字锁住的同步块入口       9: monitorenter 					      // synchronized 关键字锁住的同步块内容      10: aload_1 					          // synchronized 关键字锁住的同步块出口一：表示正常退出      11: monitorexit 					      12: goto          20      15: astore_2      16: aload_1      // synchronized 关键字锁住的同步块出口二：如果有异常我也得保证同步块被退出了      // 保证不会产生死锁，保证      17: monitorexit
```

-  **lock** 是具体的类，是**api**层面的锁。 
   - **JVM指令**：

```java
20: new           #3                  // class java/util/concurrent/locks/ReentrantLock23: dup24: invokespecial #4                  // Method java/util/concurrent/locks/ReentrantLock."<init>":()V
```


### 使用方法


- 对于 **synchronized** 的**同步代码块、同步方法**来说： 
  - **都不需要用户去手动释放锁**。
  - 当 **synchronized** 代码执行完后，**系统会自动让线程释放对锁的占用**。
- 对于 **ReentrantLock** 来说： 
  - **需要用户去手动释放锁**。
  - **如果没有主动释放锁，就有可能导致出现死锁**。
  - 所以最好使用 **lock()和unlock() 方法配合 try/finally 语句块**来完成。



### 等待可否中断


- **synchronized **不可中断 
  - 除非抛出了异常或者正常运行完成。
- **ReentrantLock** 可以中断 
  - 设置**超时方法 trylock(long timeout, TimeUnit unit)**。
  - **lockInterruptibly()** 放代码块中，调用 **interrupt()** 方法可中断。



### 加锁是否公平


- **synchronized** 默认非公平锁。
- **ReentrantLock** 可以在初始化的时候规定是否是公平锁。



### 锁绑定多个条件 Condition


- **synchronized** 没有这个功能。
- **ReentrantLock** 用来实现分组唤醒需要唤醒的线程们，可以精确唤醒。 
  - 不会像 **synchronized** 那么**要么随机唤醒一个线程，要么全都唤醒**。



### 案例（重要）


- 要求： 
  - **多线程之间按顺序调用，实现 A->B->C 三个线程启动。**
  - **A打印5次，B打印10次，C打印15次。**
  - **紧接着**
  - **A再打印5次，B再打印10次，C再打印15次。**
  - **重复 10 轮。**



```java
class shareData {    private int threadTarget = 1; // A:1 B:2 C:3    private Lock lock = new ReentrantLock();    private Condition conditionA = lock.newCondition();    private Condition conditionB = lock.newCondition();    private Condition conditionC = lock.newCondition();    public void aPrint5() {        lock.lock();        try {            // 判断线程A到底能不能继续            while (this.threadTarget != 1) {                conditionA.await();            }            // 执行            for (int i = 1; i <= 5; i++) {                System.out.println(Thread.currentThread().getName() + "线程\t" + i);            }            // 唤醒            threadTarget = 2;            conditionB.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void bPrint10() {        lock.lock();        try {            // 判断线程B到底能不能继续            while (this.threadTarget != 2) {                conditionB.await();            }            // 执行            for (int i = 1; i <= 10; i++) {                System.out.println(Thread.currentThread().getName() + "线程\t" + i);            }            // 唤醒            threadTarget = 3;            conditionC.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void cPrint15() {        lock.lock();        try {            // 判断线程C到底能不能继续            while (this.threadTarget != 3) {                conditionC.await();            }            // 执行            for (int i = 1; i <= 15; i++) {                System.out.println(Thread.currentThread().getName() + "线程\t" + i);            }            // 唤醒            threadTarget = 1;            conditionA.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }}
```


```java
public class SyncAndLockDemo {    public static void main(String[] args) {        shareData shareData = new shareData();        new Thread(() -> {            for (int i = 0; i < 10; i++) {                shareData.cPrint15();            }        }, "C").start();                new Thread(() -> {            for (int i = 0; i < 10; i++) {                shareData.aPrint5();            }        }, "A").start();                new Thread(() -> {            for (int i = 0; i < 10; i++) {                shareData.bPrint10();            }        }, "B").start();    }}
```


```java
/*    A线程	1    A线程	2    A线程	3    A线程	4    A线程	5    B线程	1    B线程	2    B线程	3    B线程	4    B线程	5    B线程	6    B线程	7    B线程	8    B线程	9    B线程	10    C线程	1    C线程	2    C线程	3    C线程	4    C线程	5    C线程	6    C线程	7    C线程	8    C线程	9    C线程	10    C线程	11    C线程	12    C线程	13    C线程	14    C线程	15    ...*/
```


#### 案例分析


- 虽然分析代码，我们可以不设置那么多 **Condition**。
- 但是我又想了以下，不是精确唤醒的话，随机唤醒，可能要唤醒好几次才能唤醒到相应的线程。
- 这中途会浪费更多的**CPU**资源。
- 所以精确唤醒某些情况下还是很有必要的。
- 而且最重要的是，没有精确唤醒，并发状态下，可能会出现死锁情况！



### 死锁情况案例（重要）


```java
package JUC.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author zhaolimin * @date 2021/11/16 * @apiNote 比较 sync 关键字和 lock 类的区别 */class shareData {    private int threadTarget = 1; // A:1 B:2 C:3    private Lock lock = new ReentrantLock();    private Condition conditionA = lock.newCondition();    //private Condition conditionB = lock.newCondition();    //private Condition conditionC = lock.newCondition();    public void aPrint5() {        lock.lock();        try {            // 判断线程A到底能不能继续            while (this.threadTarget != 1) {                conditionA.await();            }            // 执行            for (int i = 1; i <= 5; i++) {                System.out.println(Thread.currentThread().getName() + "线程\t" + i);            }            // 唤醒            threadTarget = 2;            //conditionB.signal();            conditionA.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void bPrint10() {        lock.lock();        try {            // 判断线程B到底能不能继续            while (this.threadTarget != 2) {                //conditionB.await();                conditionA.await();            }            // 执行            for (int i = 1; i <= 10; i++) {                System.out.println(Thread.currentThread().getName() + "线程\t" + i);            }            // 唤醒            threadTarget = 3;            //conditionC.signal();            conditionA.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void cPrint15() {        lock.lock();        try {            // 判断线程C到底能不能继续            while (this.threadTarget != 3) {                //conditionC.await();                conditionA.await();            }            // 执行            for (int i = 1; i <= 15; i++) {                System.out.println(Thread.currentThread().getName() + "线程\t" + i);            }            // 唤醒            threadTarget = 1;            conditionA.signal();        } catch (Exception e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }}public class SyncAndLockDemo {    public static void main(String[] args) {        shareData shareData = new shareData();        new Thread(() -> {            for (int i = 0; i < 10; i++) {                shareData.cPrint15();            }        }, "C").start();        new Thread(() -> {            for (int i = 0; i < 10; i++) {                shareData.aPrint5();            }        }, "A").start();        new Thread(() -> {            for (int i = 0; i < 10; i++) {                shareData.bPrint10();            }        }, "B").start();    }}
```


```java
/*
    A线程	1
    A线程	2
    A线程	3
    A线程	4
    A线程	5
    B线程	1
    B线程	2
    B线程	3
    B线程	4
    B线程	5
    B线程	6
    B线程	7
    B线程	8
    B线程	9
    B线程	10
    运行中。。。
*/
```


#### 案例分析


- 由于没有**精确唤醒**，我们走到线程C准备开始的时候，恰好被线程A的其它几次请求抢先抢占了 aprint5() 方法，导致此时一直在那里循环等待，然后线程C一直被阻塞，由于线程C被阻塞所以，不允许 cprint15() ，所以信号量改不回1，所以此时线程A的其它几趟也会卡着不动，等待资源释放，导致死锁。



## 获取多线程的方式


### callable接口


#### 简介


- 和 **Runnable** 接口一样是一个函数式接口。
- 它的**call**方法有返回值。
- 我觉得它的作用可能就在于**某些情况下要获取并判断线程执行的结果，所以需要用这个接口**。

# 线程池



## 线程池的主要工作

- 线程池做的**工作主要**是**控制运行的线程**的数量。
- ==处理过程中将任务放入**队列**==，然后在线程创建之后启动这些任务。
- ==如果线程数量超过了最大数量，超出数量的线程排队等待。==
- 等待其它线程执行完毕之后，再从队列中取出任务来执行。



## 特点

### **线程复用**

- **减低了资源的消耗**。
- 通过**复制利用已经创建的线程**降低线程创建和销毁造成的资源消耗。

### 控制最大并发数

- **提高响应速度**。
- 当**任务到达**时，**任务可以不需要等到线程创建就可以立即执行**。

### 管理线程

- **提高线程的可管理性**。
- 线程是**稀缺资源**，如果**无限制的创建**，不仅会**消耗系统资源，还会降低系统的稳定性**。
- 线程池可以进行**统一的分配，调优和监控**。



## 如何使用

- **ExecutorService** 接口**继承了 Executor 接口**。
- 我们**一般用 Executor 接口的池化对象来进行多态**。
- 就像我们创建 **ArrayList** 来**多态 List接口** 而不是 **Collection 接口**。



### 架构说明

| ![image-20211117110111464](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211117110111464.png) |
| :----------------------------------------------------------: |
|                           继承关系                           |





### 编码实现

- 下边几种，测试线程池用用就行了。

- ==一般自己用构造函数初始化一个线程池。==

  

#### 固定线程数

- **可控制线程最大并发数，超出的线程会在队列中等待**。

```java
/*
	靠阻塞队列 LinkedBlockingQueue 来初始化
*/
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

```java
Executors.newFixedThreadPool(int) // 执行长期的任务来说的话性能会好很多
```

```java
public class ThreadPoolDemo01 {

    public static void main(String[] args) {
        // ExecutorService 接口继承了 Executor 接口
        // 我们一般用 Executor 接口的池化对象来进行多态
        // 就像我们创建 ArrayList 来多态 List接口 而不是 Collection 接口
        // 一池五个处理线程
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        
        // 模拟十个用户来办理业务
        // 每个用户就是一个来自外部，来请求线程
        try {
            // 使用
            for (int i = 0; i < 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + 
                                       "线程\t 办理业务。。。");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // 关闭
            threadPool.shutdown();
        }
    }
}

```

```java
/*
    pool-1-thread-1线程	 办理业务。。。
    pool-1-thread-4线程	 办理业务。。。
    pool-1-thread-1线程	 办理业务。。。
    pool-1-thread-3线程	 办理业务。。。
    pool-1-thread-2线程	 办理业务。。。
    pool-1-thread-3线程	 办理业务。。。
    pool-1-thread-1线程	 办理业务。。。
    pool-1-thread-4线程	 办理业务。。。
    pool-1-thread-5线程	 办理业务。。。
    pool-1-thread-2线程	 办理业务。。。 
*/
```

- **最多就五个线程在复用满足外部的十个业务请求**。



#### 一池一线程

- 创建一个**单线程化的线程池**。
- 它只会用**唯一的工作线程来执行任务**，保证所有任务**按照指定的顺序**执行。

```java
/*
	靠阻塞队列 LinkedBlockingQueue 来初始化
*/
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

```java
Executors.newSingleThreadExecutor() // 一个任务一个任务的执行场景，唯一的工作线程来执行任务，保证所有任务按照指定的顺序执行
```

```java
package JUC.threadpool;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author zhaolimin
 * @date 2021/11/17
 * @apiNote 线程池测试
 */
public class ThreadPoolDemo01 {

    public static void main(String[] args) {
        // 一个任务一个线程，一池一线程
        ExecutorService threadPool = Executors.newSingleThreadExecutor();

        try {
            for (int i = 0; i < 10; i++) {
                threadPool.submit(() -> {
                    System.out.println(Thread.currentThread().getName() + 
                                       "线程\t 办理业务。。。");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}

```

```java
/*
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
    pool-1-thread-1线程	 正在办理业务。。。
*/
```

- **我们可以看出这个线程池中只有一个线程在被使用。**



#### 一池多线程

- 创建一个可缓存线程池。
- 如果**线程池长度超过处理的需要**，可灵活**收回空闲线程**，**若无可回收，则新建线程**。

```java
/*	靠阻塞队列 SynchronousQueue 来初始化*/public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  // 来了任务就创建线程运行，当线程空闲超过60s就给他销毁                                  new SynchronousQueue<Runnable>());}
```

```java
Executor.newCachedThreadPool() // 适用：执行很多短期异步的小程序或者负载较轻的服务器
```

```java
public void autoThreadPool() {    // 一池多线程，数量会调整    ExecutorService threadPool = Executors.newCachedThreadPool();    try {        for (int i = 0; i < 16; i++) {            threadPool.submit(() -> {                System.out.println(Thread.currentThread().getName() + "线程\t 办理业务。。。");            });        }    } catch (Exception e) {        e.printStackTrace();    } finally {        threadPool.shutdown();    }}
```

```java
/*    pool-1-thread-1线程	 办理业务。。。    pool-1-thread-5线程	 办理业务。。。    pool-1-thread-3线程	 办理业务。。。    pool-1-thread-2线程	 办理业务。。。    pool-1-thread-4线程	 办理业务。。。    pool-1-thread-8线程	 办理业务。。。    pool-1-thread-7线程	 办理业务。。。    pool-1-thread-6线程	 办理业务。。。    pool-1-thread-10线程	 办理业务。。。    pool-1-thread-9线程	 办理业务。。。    pool-1-thread-2线程	 办理业务。。。    pool-1-thread-10线程	 办理业务。。。    pool-1-thread-9线程	 办理业务。。。    pool-1-thread-6线程	 办理业务。。。    pool-1-thread-8线程	 办理业务。。。    pool-1-thread-7线程	 办理业务。。。*/
```

- **线程池中的数量是随请求使用线程的次数来定的。**
- **我的电脑最多一个线程池10个线程。**



## ThreadPoolExecutor类 （重点）



### 核心线程数

- ==核心线程会一直存在，即使没有任务。==



### 七大参数（重点）

```java
// 线程池中的常驻核心线程数// 当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列中去int corePoolSize// 线程池能够容纳“同时执行的最大线程数”，此值必须大于1int maximumPoolSize// 多余的空余线程的存活时间// 当线程池数量超过 corePoolSize 时，// 同时当空闲时间达到 keepAliveTime 时，// 多余的线程会被销毁，直到只剩下 corePoolSize 个线程为止long keepAliveTime// keepAliveTime的单位TimeUnit unit    // 任务队列，被提交但是未被执行的任务，也就是阻塞队列BlockingQueue<Runnable> workQueue    // 表示生成线程池中工作线程的线程工厂// 用于创建线程，一般用默认的即可ThreadFactory threadFactory    // 拒绝策略。表示当队列满了并且工作线程数大于等于线程池的最大线程数 maxmumPoolSize 时，// 如何来拒绝任务RejectedExecutionHandler handler
```



### 构造函数

```java
public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue<Runnable> workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler) {    // 非法参数检测    if (corePoolSize < 0 ||        maximumPoolSize <= 0 ||        maximumPoolSize < corePoolSize ||        keepAliveTime < 0)        throw new IllegalArgumentException();    // 非法引用检测    if (workQueue == null || threadFactory == null || handler == null)        throw new NullPointerException();    //     this.acc = System.getSecurityManager() == null ?        null :    AccessController.getContext();    this.corePoolSize = corePoolSize;    this.maximumPoolSize = maximumPoolSize;    this.workQueue = workQueue;    this.keepAliveTime = unit.toNanos(keepAliveTime);    this.threadFactory = threadFactory;    this.handler = handler;}
```



## 线程池工作原理（重要）

- ==对应图中 1、2、3、4 四个步骤：==
  - 如果**核心线程使用数量**到了 **corePoolSize**，
  - 那么**新的线程先放阻塞队列**里，
  - 如果**阻塞队列满**了，那么就增加**核心线程数**，
  - ==此时**增加的核心线程数**不是指**常驻的核心线程**，是指**临时的核心线程**==，
  - 当增加的**临时核心线程数**等于 **maximumPoolSize** 的时候，就**不再往线程池中添加新的临时线程**。
  - 如果**此时阻塞队列**和**线程池线程数量都达到阈值**，**并且还源源不断的有新的请求**，
  - 此时就**触发拒绝机制**。
  - 最后等到阻塞队列为空，线程池中没有线程有要处理的代码段，
  - 此时我们判断**临时核心线程的等待时间是否等于** **keepAliveTime**，如果等于，那就销毁临时核心线程。
  - **最后**我们处理完一切事物，就==**只留下了空空的阻塞队列以及我们线程池的两个常驻核心线程**==。

| **![image-20211117145623311](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211117145623311.png)** |
| :----------------------------------------------------------: |
|                           **图示**                           |



## 拒绝策略（重要）

- 以下四个**JDK内置**的拒绝策略均实现了 **RejectedExecutionHandler** 接口。

- **AbortPolicy**（默认）

  - 直接抛出 **RejectedExecutionException** 异常。

  - 阻止系统正常运行。

  - ```java
        private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();
    ```

  

- **CallerRunsPolicy**

  - **“调用者运行”**机制，是一种调节机制。
  - 该策略既**不会抛弃任务**，也**不会抛出异常**。
  - 它会将某些任务回退给调用者，从而降低新任务的流量。

- **DiscardOldestPolicy**

  - **抛弃队列中等待最久的任务**。
  - 然后把**当前任务加入到队列中尝试再次提交当前任务**。

- **DiscardPolicy**

  - **直接丢弃该任务。**
  - **不处理，不抛异常**，如果允许任务丢失的话，这是最好的一种方案。



## 自定义线程池案例



### 未使用自定义拒绝策略

#### AbortPolicy版

```java
public class CustomThreadPoolDemo {    public static void main(String[] args) {        ExecutorService threadPool = new ThreadPoolExecutor(2,5                                                            ,60L, TimeUnit.MILLISECONDS                                                            , new LinkedBlockingQueue<Runnable>(3)                                                            , Executors.defaultThreadFactory()                                                            ,new ThreadPoolExecutor.AbortPolicy());        try {            // 此时阻塞队列和线程池最大长度为 8，同时并发超过 8 的话就会造成拒绝            for (int i = 0; i < 9; i++) {          //for (int i = 0; i < 8; i++) { // 不会被拒绝                // 并发 9                threadPool.submit(() -> {                    System.out.println(Thread.currentThread().getName() + "线程\t 处理业务！");                });            }        } catch (Exception e) {            e.printStackTrace();        } finally {            threadPool.shutdown();        }    }}
```

```java
/*    pool-1-thread-1线程	 处理业务！    pool-1-thread-5线程	 处理业务！    pool-1-thread-4线程	 处理业务！    pool-1-thread-3线程	 处理业务！    pool-1-thread-2线程	 处理业务！    pool-1-thread-5线程	 处理业务！    pool-1-thread-4线程	 处理业务！    pool-1-thread-1线程	 处理业务！    java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@3b9a45b3 rejected from java.util.concurrent.ThreadPoolExecutor@7699a589[Running, pool size = 5, active threads = 5, queued tasks = 3, completed tasks = 0]        at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)        at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)        at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)        at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:112)        at JUC.threadpool.CustomThreadPoolDemo.main(CustomThreadPoolDemo.java:23)*/
```



#### CallerRunsPolicy版

```java
public class CustomThreadPoolDemo {    public static void main(String[] args) {        ExecutorService threadPool = new ThreadPoolExecutor(2,5                ,60L, TimeUnit.MILLISECONDS                , new LinkedBlockingQueue<Runnable>(3)                , Executors.defaultThreadFactory()                ,new ThreadPoolExecutor.CallerRunsPolicy());        try {            // 超出线程池允许最大并发度            for (int i = 0; i < 9; i++) {                threadPool.submit(() -> {                    System.out.println(Thread.currentThread().getName() + "线程\t 处理业务！");                });            }        } catch (Exception e) {            e.printStackTrace();        } finally {            threadPool.shutdown();        }    }}
```

```java
/*    pool-1-thread-2线程	 处理业务！    pool-1-thread-4线程	 处理业务！    pool-1-thread-2线程	 处理业务！    main线程	 处理业务！ 			// 没报异常也没报错，把业务回退给他的母线程运行，此时这个线程的母线程为main线程    pool-1-thread-1线程	 处理业务！    pool-1-thread-3线程	 处理业务！    pool-1-thread-2线程	 处理业务！    pool-1-thread-4线程	 处理业务！    pool-1-thread-5线程	 处理业务！*/
```

- 其它俩个慎用。



### 使用自定义拒绝策略





## 如何合理的配置线程池线程数



### CPU密集型

- CPU密集的意思是：
  - 该任务需要大量的运算，如果没有阻塞，CPU一直全速运行。
  - **CPU的密集任务**只有**在真正的多核CPU**上才可能得到加速（**通过多线程**）。
  - 所以单核CPU就别想加速了，再怎么加速也只有一个核心，最快也就一个核心的算力。

- 先查看我们的**CPU核心数**，再进一步去设置 **corePoolSize** 的大小。
- `System.out.println(Runtime.getRuntime().availableProcessors());`
- 一般我们的**CPU密集型任务配置尽可能少的线程数量**。
- ==公式大概是：CPU核心数+1个线程的线程池。==



### IO密集型

- **即该任务需要大量的IO，即大量的阻塞。**
- **单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。**
- 所以在IO密集型任务中使用多线程可以大大的加速程序的运行。
- **在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间，所以也能有加速效果。**

- 因为**IO密集型**的**任务线程**不一定**一直在执行任务**。
- 则应该配置尽可能多的线程。
  - 一、**CPU核数 * 2**
  - 二、**CPU核数 / （1 - 阻塞系数） （阻塞系数在0.8~0.9）**



## 死锁

### 是什么？

- 是**指两个或者两个以上的线程或进程**在执行的过程中，因**抢夺资源而造成的一种互相等待的现象**。
- 造成这种现象后**如果没有外力干涉那么就无法进行下去**，这就是死锁。
- 如果**系统资源充足**，**线程或进程**的**资源请求都能满足**，**死锁出现的可能性就会很低**，而不是不会出现。

| ![image-20211118133238601](C:\Users\noblegasesgoo\AppData\Roaming\Typora\typora-user-images\image-20211118133238601.png) |
| :----------------------------------------------------------: |
|                           **图示**                           |



### 造成原因

- 系统资源不足。
- 进程运行推进顺序不合适。
- 资源分配不当。
- ==**请求并持有资源，互斥，不可中断，循环等待。**==



### 编码

```java
package JUC.deadlock;import java.util.concurrent.TimeUnit;/** * @author zhaolimin * @date 2021/11/18 * @apiNote 死锁测试 */class HoldThread implements Runnable{    private String lock1;    private String lock2;    public HoldThread(String lockA, String lockB) {        this.lock1 = lockA;        this.lock2 = lockB;    }    @Override    public void run() {        // 可重入的前提是同一个锁，所以这里不是可重入锁        synchronized (lock1) {            System.out.println(Thread.currentThread().getName() + "线程\t 持有" + lock1 + "\t正在尝试获得" + lock2);                        try {                TimeUnit.SECONDS.sleep(5);            } catch (InterruptedException e) {                e.printStackTrace();            }                        synchronized (lock2) {            }        }    }}public class DeadLockDemo {    public static void main(String[] args) {        String lockA = "lockA";        String lockB = "lockB";        new Thread(new HoldThread(lockA,lockB),"A").start();        new Thread(new HoldThread(lockB,lockA),"B").start();    }}
```

```java
/*    A线程	 持有lockA	正在尝试获得lockB    B线程	 持有lockB	正在尝试获得lockA    ...*/
```

- ==字符串是常量，所以说，两个线程抢的锁是相同的两把锁。==
- ==如果是别的引用的话，这里的锁就是4把不同的锁，那么例子就出错。==
- ==而且可能出现，A线程已经全部运行完了获得了两把锁，B线程一把锁都没获得的情况，也可能反过来。==



### 定位分析

- **linux**：

  - `ps -ef|grep xxxx`

- **windows**：

  - **windows**下的**java程序运行**，也有类似**linux下的查看进程的ps命令**，但是目前我们**只看java**。
  - **jps.exe = java ps** 可以用 `jps -l`
  - `jps -l` 查看正在运行的java程序，找到**可疑进程的PID**。
  - `jstack PID` 查看当前进程的异常栈，有没有报出死锁。

  ```java
  Java stack information for the threads listed above:==================================================="B":        at JUC.deadlock.HoldThread.run(DeadLockDemo.java:35)        - waiting to lock <0x00000007160d5f48> (a java.lang.String)        - locked <0x00000007160d5f80> (a java.lang.String)        at java.lang.Thread.run(Thread.java:748)"A":        at JUC.deadlock.HoldThread.run(DeadLockDemo.java:35)        - waiting to lock <0x00000007160d5f80> (a java.lang.String)        - locked <0x00000007160d5f48> (a java.lang.String)        at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.D:\DevelopmentEnvironment\Git\GitRepository\javase-learning>
  ```

  



